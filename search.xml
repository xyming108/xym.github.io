<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>数据结构_二叉树的应用_练习题</title>
    <url>/2020/03/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%94%E7%94%A8-%E7%BB%83%E4%B9%A0%E9%A2%98/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>树与二叉树的应用包括二叉排序树、平衡二叉树、哈夫曼树等等</p>
<h5 id="二叉排序树的一些基本操作"><a href="#二叉排序树的一些基本操作" class="headerlink" title="二叉排序树的一些基本操作"></a>二叉排序树的一些基本操作</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//二叉排序树的非递归查找</span></span><br><span class="line"><span class="function">BiTree <span class="title">BSTSearch</span><span class="params">(BiTree T, ElemType key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (T != <span class="literal">nullptr</span> &amp;&amp; T-&gt;data != key) &#123;</span><br><span class="line">        <span class="keyword">if</span> (key &lt; T-&gt;data)</span><br><span class="line">            T = T-&gt;lchild;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            T = T-&gt;rchild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二叉排序树的递归查找</span></span><br><span class="line"><span class="function">BiTree <span class="title">BSTSearch2</span><span class="params">(BiTree T, ElemType key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (key == T-&gt;data)</span><br><span class="line">        <span class="keyword">return</span> T;</span><br><span class="line">    <span class="keyword">if</span> (key &lt; T-&gt;data)</span><br><span class="line">        <span class="keyword">return</span> BSTSearch2(T-&gt;lchild, key);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> BSTSearch2(T-&gt;rchild, key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二叉排序树的插入</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BSTInsert</span><span class="params">(BiTree &amp;T, ElemType key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//当查找失败时，会开始插入key结点</span></span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        T = (BiTree) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTree));</span><br><span class="line">        T-&gt;data = key;</span><br><span class="line">        T-&gt;lchild = T-&gt;rchild = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key == T-&gt;data) &#123;</span><br><span class="line">        <span class="comment">//若已经存在，则插入失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &lt; T-&gt;data)</span><br><span class="line">        <span class="keyword">return</span> BSTInsert(T-&gt;lchild, key);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> BSTInsert(T-&gt;rchild, key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二叉排序树的构造</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BSTCreate</span><span class="params">(BiTree &amp;T, ElemType key[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//初始时二叉排序树为空</span></span><br><span class="line">    T = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">        BSTInsert(T, key[i]);</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="二叉树树的应用"><a href="#二叉树树的应用" class="headerlink" title="二叉树树的应用"></a>二叉树树的应用</h5><p>判断一个给定的二叉树是否是二叉排序树，算法思想，因为二叉排序树的中序遍历是从小到大的，因此只需判断其中序遍历是否从小到大有序即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> MIN = <span class="number">-32767</span>;    <span class="comment">//首先设定一个用于比较的最小值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">JudegBST</span><span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> b1, b2;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;   <span class="comment">//空树</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        b1 = JudegBST(T-&gt;lchild);</span><br><span class="line">        <span class="keyword">if</span> (b1 == <span class="number">0</span> || MIN &gt;= T-&gt;data)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        MIN = T-&gt;data;</span><br><span class="line">        b2 = JudegBST(T-&gt;rchild);</span><br><span class="line">        <span class="keyword">return</span> b2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>求出指定结点在二叉排序树中的层次，算法思想：查找一次就下降一层</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SarchLevel</span><span class="params">(BiTree T, BiTree key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    BiTree p = T;</span><br><span class="line">    <span class="keyword">if</span> (T) &#123;</span><br><span class="line">        n++;</span><br><span class="line">        <span class="keyword">while</span> (p-&gt;data != key-&gt;data) &#123;</span><br><span class="line">            <span class="keyword">if</span> (key-&gt;data &lt; p-&gt;data)</span><br><span class="line">                p = p-&gt;lchild;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p = p-&gt;rchild;</span><br><span class="line">            n++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用二叉树遍历的思想判断一个二叉树是否是平衡二叉树，算法思想：高度为0或1，则为平衡二叉树，否则左右子树的高度差不能大于1，balance判断是否是平衡二叉树，h表示高度，int &amp;balance, int &amp;h加引用(&amp;)的原因是会被修改</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">JudgeAVL</span><span class="params">(BiTree T, <span class="keyword">int</span> &amp;balance, <span class="keyword">int</span> &amp;h)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//左右子树的平衡标记和高度</span></span><br><span class="line">    <span class="keyword">int</span> bl, br, hl, hr;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">nullptr</span>) &#123; <span class="comment">//树空</span></span><br><span class="line">        balance = <span class="number">1</span>;</span><br><span class="line">        h = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (T-&gt;lchild == <span class="literal">nullptr</span> &amp;&amp; T-&gt;rchild == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">//仅有根结点</span></span><br><span class="line">        h = <span class="number">1</span>;</span><br><span class="line">        balance = <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        JudgeAVL(T-&gt;rchild, bl, hl);</span><br><span class="line">        JudgeAVL(T-&gt;rchild, br, hr);</span><br><span class="line">        <span class="comment">//这里加1加的是根结点，因为前面已经处理了根结点</span></span><br><span class="line">        h = (hl &gt; hr ? hl : hr) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">abs</span>(hl - hr) &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="comment">//左右子树都平衡才整体平衡</span></span><br><span class="line">            balance = bl &amp; br;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            balance = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>求出给定二叉排序序树中的最大值和最小值的关键字，算法思想：对于二叉排序树，最小值在左下角，最大值在右下角</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ElemType <span class="title">MaxKey</span><span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (T-&gt;rchild != <span class="literal">nullptr</span>)</span><br><span class="line">        T = T-&gt;rchild;</span><br><span class="line">    <span class="keyword">return</span> T-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ElemType <span class="title">MinKey</span><span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (T-&gt;lchild != <span class="literal">nullptr</span>)</span><br><span class="line">        T = T-&gt;lchild;</span><br><span class="line">    <span class="keyword">return</span> T-&gt;data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从大到小输出二叉排序树中所有不小于k的值，算法思想：因为是从大到小输出，所以先遍历右子树，再遍历左子树，用递归的方法可以从最大开始，直到最小</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OutPutKey</span><span class="params">(BiTree T, ElemType k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (T-&gt;rchild != <span class="literal">nullptr</span>)</span><br><span class="line">        OutPutKey(T-&gt;rchild, k);</span><br><span class="line">    <span class="keyword">if</span> (T-&gt;data == k)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; T-&gt;data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">if</span> (T-&gt;lchild != <span class="literal">nullptr</span>)</span><br><span class="line">        OutPutKey(T-&gt;lchild, k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>C++</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构_二叉树的遍历/线索二叉树</title>
    <url>/2020/03/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86-%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>​    原始头文件和一些其中会用到的函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by XuYiMing on 2020/3/2.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二叉树的链式存储</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> &#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125; BiTNode, *BiTree;</span><br><span class="line"></span><br><span class="line"><span class="function">ElemType <span class="title">visit</span><span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> T-&gt;data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><h4 id="二叉树遍历方法"><a href="#二叉树遍历方法" class="headerlink" title="二叉树遍历方法"></a>二叉树遍历方法</h4></li>
</ul>
<ol>
<li><h6 id="用递归方法解决遍历问题"><a href="#用递归方法解决遍历问题" class="headerlink" title="用递归方法解决遍历问题"></a>用递归方法解决遍历问题</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;先序遍历</span><br><span class="line">void PreOrder(BiTree T) &#123;</span><br><span class="line">    if (T !&#x3D; nullptr) &#123;</span><br><span class="line">        visit(T);</span><br><span class="line">        PreOrder(T-&gt;lchild);</span><br><span class="line">        PreOrder(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;中序遍历</span><br><span class="line">void InOrder(BiTree T) &#123;</span><br><span class="line">    if (T !&#x3D; nullptr) &#123;</span><br><span class="line">        InOrder(T-&gt;lchild);</span><br><span class="line">        visit(T);</span><br><span class="line">        InOrder(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;后序遍历</span><br><span class="line">void PostOrder(BiTree T) &#123;</span><br><span class="line">    if (T !&#x3D; nullptr) &#123;</span><br><span class="line">        PostOrder(T-&gt;lchild);</span><br><span class="line">        PostOrder(T-&gt;rchild);</span><br><span class="line">        visit(T);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;层次遍历</span><br><span class="line">void LevelOrder(BiTree T) &#123;</span><br><span class="line">    queue&lt;BiTree&gt; q;</span><br><span class="line">    BiTree p &#x3D; T;</span><br><span class="line">    q.push(T);</span><br><span class="line">    while (!q.empty()) &#123;</span><br><span class="line">        q.pop();</span><br><span class="line">        visit(p);</span><br><span class="line">        if (p-&gt;lchild !&#x3D; nullptr)</span><br><span class="line">            q.push(p-&gt;lchild);</span><br><span class="line">        else if (p-&gt;rchild !&#x3D; nullptr)</span><br><span class="line">            q.push(p-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
<li><h6 id="用非递归方法解决遍历问题"><a href="#用非递归方法解决遍历问题" class="headerlink" title="用非递归方法解决遍历问题"></a>用非递归方法解决遍历问题</h6></li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//先序遍历非递归算法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrder2</span><span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    BiTree p = T;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">nullptr</span> || !s.empty()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p) &#123;</span><br><span class="line">            visit(p);</span><br><span class="line">            s.push(p-&gt;data);</span><br><span class="line">            p = p-&gt;lchild;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            s.pop();</span><br><span class="line">            p = p-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序遍历非递归算法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrder2</span><span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    BiTree p = T;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">nullptr</span> || !s.empty()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p) &#123;</span><br><span class="line">            s.push(p-&gt;data);</span><br><span class="line">            p = p-&gt;lchild;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            s.pop();</span><br><span class="line">            visit(p);</span><br><span class="line">            p = p-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后序遍历非递归算法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrder2</span><span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;BiTree&gt; s;</span><br><span class="line">    BiTree p = T;</span><br><span class="line">    <span class="comment">//r为辅助指针，用于指向最近访问过的结点</span></span><br><span class="line">    BiTree r = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span> (p || !s.empty()) &#123;</span><br><span class="line">        <span class="comment">//走到最左边，找到后序遍历的第一个结点</span></span><br><span class="line">        <span class="keyword">if</span> (p) &#123;</span><br><span class="line">            s.push(p);</span><br><span class="line">            p = p-&gt;lchild;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//读取栈顶结点</span></span><br><span class="line">            p = s.top();</span><br><span class="line">            <span class="comment">//右子节点存在且未被访问过</span></span><br><span class="line">            <span class="keyword">if</span> (p-&gt;rchild &amp;&amp; p-&gt;rchild != r) &#123;</span><br><span class="line">                p = p-&gt;rchild;</span><br><span class="line">                s.push(p);</span><br><span class="line">                p = p-&gt;lchild;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//否则从栈中弹出还未被访问的结点</span></span><br><span class="line">                s.pop();</span><br><span class="line">                visit(p);</span><br><span class="line">                <span class="comment">//把r指向该节点已被访问</span></span><br><span class="line">                r = p;</span><br><span class="line">                <span class="comment">//每次出栈访问完一个结点都是该结点的子树，需将p置null</span></span><br><span class="line">                p = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><h4 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//线索二叉树的存储结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span> &#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">    <span class="keyword">int</span> ltag, rtag;</span><br><span class="line">    <span class="comment">//tag为0表示孩子，为1表示前驱/后继</span></span><br><span class="line">&#125; ThreadNode, *ThreadTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序线索二叉树的递归算法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InThread</span><span class="params">(ThreadTree &amp;p, ThreadTree &amp;pre)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">//递归线索化左子树</span></span><br><span class="line">        InThread(p-&gt;lchild, pre);</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;lchild == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            p-&gt;lchild = pre;</span><br><span class="line">            p-&gt;ltag = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//建立前驱结点的后继线索</span></span><br><span class="line">        <span class="keyword">if</span> (pre != <span class="literal">nullptr</span> &amp;&amp; pre-&gt;rchild == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            pre-&gt;rchild = p;</span><br><span class="line">            pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = p;</span><br><span class="line">        InThread(pre-&gt;rchild, pre);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//建立中序线索二叉树的过程</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateInThread</span><span class="params">(ThreadTree T)</span> </span>&#123;</span><br><span class="line">    ThreadTree pre = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (T != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">//线索化二叉树</span></span><br><span class="line">        InThread(T, pre);</span><br><span class="line">        <span class="comment">//处理遍历后的最后一个结点</span></span><br><span class="line">        pre-&gt;rchild = <span class="literal">nullptr</span>;</span><br><span class="line">        pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>C++</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构_二叉树遍历_线索二叉树_练习题</title>
    <url>/2020/03/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86-%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91-%E7%BB%83%E4%B9%A0%E9%A2%98/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ol>
<li><p>给出二叉树自下而上，自右到左的层次遍历算法，算法思想：在一般的层次遍历的同时出队，并将结点放入栈中，最后从栈顶开始出栈即是逆序的层次遍历</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ReverseLevel</span><span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;BiTree&gt; s;</span><br><span class="line">    <span class="built_in">queue</span>&lt;BiTree&gt; q;</span><br><span class="line">    BiTree p;</span><br><span class="line">    <span class="keyword">if</span> (T) &#123;</span><br><span class="line">        q.push(T);      <span class="comment">//将根结点入队</span></span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;    <span class="comment">//当队列不为空时</span></span><br><span class="line">            p = q.front();      <span class="comment">//结点出队</span></span><br><span class="line">            q.pop();            <span class="comment">//从删除该结点</span></span><br><span class="line">            s.push(p);          <span class="comment">//把结点放入栈</span></span><br><span class="line">            <span class="keyword">if</span> (p-&gt;lchild != <span class="literal">nullptr</span>)</span><br><span class="line">                q.push(p);</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;rchild != <span class="literal">nullptr</span>)</span><br><span class="line">                q.push(p);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!s.empty()) &#123;</span><br><span class="line">            p = s.top();</span><br><span class="line">            s.pop();</span><br><span class="line">            visit(p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>假设二叉树采用二叉链表存储结构，设计非递归算法求二叉树的高度，算法思想：采用层次遍历，用level记录层数，设置变量last指向当前层最右结点，当遍历到last时，层数加1</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BiTdepth1</span><span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!T)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;   <span class="comment">//树空返回0</span></span><br><span class="line">    <span class="keyword">int</span> front = <span class="number">-1</span>, rear = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//用于指向当前层的最后一个节点，level记录层数</span></span><br><span class="line">    <span class="keyword">int</span> last = <span class="number">0</span>, level = <span class="number">0</span>;</span><br><span class="line">    BiTree Q[MaxSize];  <span class="comment">//建立二叉树结点指针类型的队列</span></span><br><span class="line">    Q[++rear] = T;  <span class="comment">//将根结点入队</span></span><br><span class="line">    BiTree p;</span><br><span class="line">    <span class="keyword">while</span> (front &lt; rear) &#123;  <span class="comment">//队不空</span></span><br><span class="line">        p = Q[++front];     <span class="comment">//取出正在访问的结点</span></span><br><span class="line">        <span class="keyword">if</span> (p-&gt;lchild)</span><br><span class="line">            Q[++rear] = p-&gt;lchild;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;rchild)</span><br><span class="line">            Q[++rear] = p-&gt;rchild;</span><br><span class="line">        <span class="keyword">if</span> (front == last) &#123;    <span class="comment">//到一层的最后一个结点时</span></span><br><span class="line">            level++;        <span class="comment">//层数加一</span></span><br><span class="line">            last = rear;    <span class="comment">//把last下一层的最后一个结点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> level;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归法解决此题</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BiTdepth2</span><span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!T)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ldep = BiTdepth2(T-&gt;lchild);</span><br><span class="line">    <span class="keyword">int</span> rdep = BiTdepth2(T-&gt;rchild);</span><br><span class="line">    <span class="keyword">if</span> (ldep &gt; rdep)</span><br><span class="line">        <span class="keyword">return</span> ldep + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> rdep + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>设一棵二叉树中各结点的值互不相同，其先序遍历和后序遍历序列分别存放于A和B数组，编写算法建立二叉链表</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">BiTree <span class="title">AB_Create</span><span class="params">(ElemType A[], ElemType B[], <span class="keyword">int</span> l1, <span class="keyword">int</span> h1, <span class="keyword">int</span> l2, <span class="keyword">int</span> h2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//l1, h1, l2, h2分别为先序和中序的第一个和最后一个结点</span></span><br><span class="line">    <span class="comment">//假设初始调用时：l1=l2=1, h1=h2=n</span></span><br><span class="line">    BiTree root = (BiTree) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTree));      <span class="comment">//建立根结点</span></span><br><span class="line">    root-&gt;data = A[l1];    <span class="comment">//根结点</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = l2; B[i] != root-&gt;data; i++);          <span class="comment">//在中序序列中找到根结点的划分</span></span><br><span class="line">    <span class="keyword">int</span> Llen = i - l2;      <span class="comment">//左子树长度</span></span><br><span class="line">    <span class="keyword">int</span> Rlen = h2 - i;      <span class="comment">//右子树长度</span></span><br><span class="line">    <span class="keyword">if</span> (Llen)       <span class="comment">//递归建立左子树</span></span><br><span class="line">        root-&gt;lchild = AB_Create(A, B, l1 + <span class="number">1</span>, l1 + Llen, l2, l2 + Llen - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        root-&gt;lchild = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (Rlen)       <span class="comment">//递归建立右子树</span></span><br><span class="line">        root-&gt;rchild = AB_Create(A, B, h1 - Rlen + <span class="number">1</span>, h1, h2 - Rlen + <span class="number">1</span>, h2);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        root-&gt;rchild = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>二叉树链式存储，判断是否是完全二叉树，算法思想：层次遍历，若出现空节点后还有非空节点，则不是完全二叉树</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsComplete</span><span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;BiTree&gt; q;</span><br><span class="line">    <span class="keyword">if</span> (!T)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;       <span class="comment">//空树为满二叉树</span></span><br><span class="line">    BiTree p;</span><br><span class="line">    q.push(T);</span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        p = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">if</span> (p) &#123;</span><br><span class="line">            q.push(p-&gt;lchild);</span><br><span class="line">            q.push(p-&gt;rchild);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//这一步跳过空节点，若之后还出现非空节点，则不是</span></span><br><span class="line">            <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">                p = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                <span class="keyword">if</span> (p)</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>计算一棵链式二叉树所有双分支结点个数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DsonsNode</span><span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (T-&gt;lchild != <span class="literal">nullptr</span> &amp;&amp; T-&gt;rchild != <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="comment">//若找到了含有两个孩子结点的结点，则+1，并继续往下找</span></span><br><span class="line">        <span class="keyword">return</span> DsonsNode(T-&gt;lchild) + DsonsNode(T-&gt;rchild) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">//否则继续往下找，但是此时不计个数</span></span><br><span class="line">        <span class="keyword">return</span> DsonsNode(T-&gt;lchild) + DsonsNode(T-&gt;rchild);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>把树B中所有结点的左右子树交换的函数，算法思想：首先交换B结点的左孩子的左右子树，然后交换B结点的右孩子的左右子树，最后交换B结点的左右孩子</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BiTswap</span><span class="params">(BiTree B)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (B) &#123;</span><br><span class="line">        <span class="comment">//递归交换左右子树</span></span><br><span class="line">        BiTswap(B-&gt;lchild);</span><br><span class="line">        BiTswap(B-&gt;rchild);</span><br><span class="line">        <span class="comment">//交换左右子树</span></span><br><span class="line">        BiTree T = B-&gt;lchild;</span><br><span class="line">        B-&gt;lchild = B-&gt;rchild;</span><br><span class="line">        B-&gt;rchild = T;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>C++</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构_栈</title>
    <url>/2020/03/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h5 id="数据结构栈的实现！"><a href="#数据结构栈的实现！" class="headerlink" title="数据结构栈的实现！"></a>数据结构栈的实现！</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by XuYiMing on 2020/2/21.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 50</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElementType;</span><br><span class="line"></span><br><span class="line"><span class="comment">//*********************顺序栈*****************</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    ElementType data[MaxSize];</span><br><span class="line">    <span class="keyword">int</span> top;</span><br><span class="line">&#125; SqStack;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitStack</span><span class="params">(SqStack &amp;s)</span> </span>&#123;        <span class="comment">//栈初始化</span></span><br><span class="line">    s.top = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">StackEmpty</span><span class="params">(SqStack &amp;s)</span> </span>&#123;       <span class="comment">//栈判空</span></span><br><span class="line">    <span class="keyword">if</span> (s.top == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">PushStack</span><span class="params">(SqStack &amp;s, ElementType x)</span> </span>&#123;     <span class="comment">//进栈</span></span><br><span class="line">    <span class="keyword">if</span> (s.top + <span class="number">1</span> == MaxSize)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    s.data[++s.top] = x;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">PopStack</span><span class="params">(SqStack &amp;s, ElementType &amp;x)</span> </span>&#123;     <span class="comment">//出栈</span></span><br><span class="line">    <span class="keyword">if</span> (s.top == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    x = s.data[s.top--];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">GetTop</span><span class="params">(SqStack s, ElementType &amp;x)</span> </span>&#123;        <span class="comment">//读栈顶元素</span></span><br><span class="line">    <span class="keyword">if</span> (s.top == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    x = s.data[s.top];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//*****************链栈******************</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span> &#123;</span></span><br><span class="line">    ElementType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; *LiStack;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>C++</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构_链式表</title>
    <url>/2020/02/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E5%BC%8F%E8%A1%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h5 id="数据结构链式表的实现！"><a href="#数据结构链式表的实现！" class="headerlink" title="数据结构链式表的实现！"></a>数据结构链式表的实现！</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by XuYiMing on 2020/2/3.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////单链表//////////////</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> &#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; LNode, *LinkList; <span class="comment">// *LinkList表示人为增加的头结点，也可以用LNode *表示，LinkList是全局变量 指向头结点，可以这样定义：LNode *LinkList</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//头插法建立单链表（输出时会得到反序的链表）</span></span><br><span class="line"><span class="function">LinkList <span class="title">List_HeadInsert</span><span class="params">(LinkList &amp;L)</span> </span>&#123;     <span class="comment">//时间复杂度为O(n)</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    LinkList s;     <span class="comment">//LNode *s;</span></span><br><span class="line">    L = (LinkList) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));   <span class="comment">//L = (LNode *) malloc(sizeof(LNode));  为头结点申请内存分配</span></span><br><span class="line">    L-&gt;next = <span class="literal">nullptr</span>;     <span class="comment">//初始化为空链表</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入结点的值，输入9999表示结束：&quot;</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">    <span class="keyword">while</span> (x != <span class="number">9999</span>) &#123;</span><br><span class="line">        s = (LinkList) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">        s-&gt;data = x;</span><br><span class="line">        s-&gt;next = L-&gt;next;</span><br><span class="line">        L-&gt;next = s;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入结点的值，输入9999表示结束：&quot;</span>;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//尾插法建立单链表（输出时会得到正序的链表）</span></span><br><span class="line"><span class="function">LinkList <span class="title">List_TailInsert</span><span class="params">(LinkList &amp;L)</span> </span>&#123;     <span class="comment">//时间复杂度为O(n)</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    L = (LinkList) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    LinkList s, r = L;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入结点的值，输入9999表示结束：&quot;</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">    <span class="keyword">while</span> (x != <span class="number">9999</span>) &#123;</span><br><span class="line">        s = (LinkList) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">        s-&gt;data = x;</span><br><span class="line">        r-&gt;next = s;</span><br><span class="line">        r = s;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入结点的值，输入9999表示结束：&quot;</span>;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">    &#125;</span><br><span class="line">    r-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//按序号查找结点值（时间复杂度为O(n)）</span></span><br><span class="line"><span class="function">LinkList <span class="title">GetElem</span><span class="params">(LinkList L, <span class="keyword">int</span> i)</span> </span>&#123;       <span class="comment">//因为不会对链表进行改动，所以可以不用 &amp;L，直接用 L</span></span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line">    LinkList p = L-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>)     <span class="comment">//返回头结点</span></span><br><span class="line">        <span class="keyword">return</span> L;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span> (p &amp;&amp; j &lt; i) &#123;    <span class="comment">//从第一个结点出发，逐个往下查找第i个结点</span></span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;   <span class="comment">//返回第i个结点的指针，若i大于表长则返回 NULL</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//按值查找表结点（时间复杂度为O(n)）</span></span><br><span class="line"><span class="function">LinkList <span class="title">LocateElem</span><span class="params">(LinkList L, ElemType e)</span> </span>&#123;</span><br><span class="line">    LinkList p = L-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (p-&gt;data != e &amp;&amp; p != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;       <span class="comment">//找到则返回该结点指针，否则返回 NULL</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在位置i上插入新值e</span></span><br><span class="line"><span class="function">LinkList <span class="title">ListInsert</span><span class="params">(LinkList &amp;L, <span class="keyword">int</span> i, ElemType e)</span> </span>&#123;</span><br><span class="line"><span class="comment">//法一：</span></span><br><span class="line"><span class="comment">// （对位置i前插操作，时间复杂度为O（n），对位置i的前驱结点后插操作，时间复杂度O（1））</span></span><br><span class="line"><span class="comment">//主要消耗时间在查找上</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    LinkList p = GetElem(L, i - <span class="number">1</span>);    <span class="comment">//找到要插入的位置的前驱结点</span></span><br><span class="line">    LinkList s;</span><br><span class="line">    s = (LinkList) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));   <span class="comment">//新建一个结点放要插入的值</span></span><br><span class="line">    s-&gt;data = e;</span><br><span class="line">    s-&gt;next = p-&gt;next;  <span class="comment">//对位置i的前驱结点后插操作</span></span><br><span class="line">    p-&gt;next = s;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line"><span class="comment">//法二：</span></span><br><span class="line"><span class="comment">//可以直接把值插在位置i结点的后面，然后交换值(时间复杂度为O（1）)，假设已经知道i位置的结点Q,插入其前面的结点为s</span></span><br><span class="line"><span class="comment">//    s-&gt;next = Q-&gt;next;</span></span><br><span class="line"><span class="comment">//    Q-&gt;next = s;</span></span><br><span class="line"><span class="comment">//    ElemType temp = Q-&gt;data;</span></span><br><span class="line"><span class="comment">//    Q-&gt;data = s-&gt;data;</span></span><br><span class="line"><span class="comment">//    s-&gt;data = temp;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除位置i结点操作</span></span><br><span class="line"><span class="function">LinkList <span class="title">ListDelete</span><span class="params">(LinkList &amp;L, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line"><span class="comment">//法一：</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">    LinkList p = GetElem(L, i - <span class="number">1</span>); <span class="comment">//寻找前驱结点</span></span><br><span class="line">    LinkList q = p-&gt;next;   <span class="comment">//把q指向要删除结点</span></span><br><span class="line">    p-&gt;next = q-&gt;next;</span><br><span class="line">    ElemType e = q-&gt;data;</span><br><span class="line">    <span class="built_in">free</span>(q);    <span class="comment">//释放存储空间</span></span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line"><span class="comment">//法二：</span></span><br><span class="line"><span class="comment">//假设要删除Q点，可以把后继结点的值赋给自身（时间复杂度为O（1））</span></span><br><span class="line"><span class="comment">//    q = Q-&gt;next;</span></span><br><span class="line"><span class="comment">//    Q-&gt;data = Q-&gt;next-&gt;data;</span></span><br><span class="line"><span class="comment">//    Q-&gt;next = q-&gt;next;</span></span><br><span class="line"><span class="comment">//    free(q);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求表长长度</span></span><br><span class="line"><span class="function">ElemType <span class="title">ListLength</span><span class="params">(LinkList L)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    LinkList p = L;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p-&gt;next != <span class="literal">nullptr</span>) &#123;    <span class="comment">//（p-&gt;next != nullptr指下一个结点， p != nullptr指当前结点）</span></span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;个数为：&quot;</span> &lt;&lt; count &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出链表（针对有头结点的）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">List_show</span><span class="params">(LinkList &amp;L)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    LinkList p = L;</span><br><span class="line">    p = p-&gt;next;</span><br><span class="line"><span class="comment">//    do &#123;</span></span><br><span class="line"><span class="comment">//        cout &lt;&lt; p-&gt;data &lt;&lt; &quot; &quot;;</span></span><br><span class="line"><span class="comment">//        p = p-&gt;next;</span></span><br><span class="line"><span class="comment">//    &#125; while (L-&gt;next != nullptr);</span></span><br><span class="line">    <span class="keyword">int</span> m = ListLength(L);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; p-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">///////////////////////双链表/////////////////////////</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span> &#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span> *<span class="title">prior</span>, *<span class="title">next</span>;</span></span><br><span class="line">&#125; DNode, *DLinkList;</span><br><span class="line"></span><br><span class="line"><span class="comment">//双链表的按序号查找操作</span></span><br><span class="line"><span class="function">DLinkList <span class="title">DGetElem</span><span class="params">(DLinkList L, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line"><span class="comment">//..........................</span></span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//双链表的插入操作(头插法)</span></span><br><span class="line"><span class="function">DLinkList <span class="title">DListInsert</span><span class="params">(DLinkList &amp;L, <span class="keyword">int</span> i, ElemType e)</span> </span>&#123;</span><br><span class="line">    DLinkList p = DGetElem(L, i - <span class="number">1</span>);   <span class="comment">//在p后面插入s</span></span><br><span class="line">    DLinkList s;</span><br><span class="line">    s = (DLinkList) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DNode));</span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next-&gt;prior = s;</span><br><span class="line">    s-&gt;prior = p;</span><br><span class="line">    p-&gt;next = s;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//双链表的删除操作(头插法)</span></span><br><span class="line"><span class="function">DLinkList <span class="title">DListDelete</span><span class="params">(DLinkList &amp;L, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    DLinkList p = DGetElem(L, i - <span class="number">1</span>);   <span class="comment">//在p后面删除q</span></span><br><span class="line">    DLinkList q = p-&gt;next;</span><br><span class="line">    p-&gt;next = q-&gt;next;</span><br><span class="line">    q-&gt;next-&gt;prior = p;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//循环单/双链表******************</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">void 判空() &#123;</span></span><br><span class="line"><span class="comment">	LinkList M;</span></span><br><span class="line"><span class="comment">	DLinkList L;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">M-&gt;next == M;		//循环单链表判空</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">L-&gt;next == L;</span></span><br><span class="line"><span class="comment">L-&gt;prior == L;		//循环双链表判空</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//静态链表，用数组实现链式的存储方式(适用于不借助指针)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SDNode</span> &#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">&#125; SLinkList[MaxSize];</span><br><span class="line"></span><br><span class="line"><span class="comment">///////////////////第40页综合应用题//////////////////////////</span></span><br><span class="line"><span class="comment">//设计一个递归算法，删除不带头结点的单链表L中所有值为x的结点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test1_Delete_x</span><span class="params">(LinkList &amp;L, ElemType x)</span> </span>&#123;</span><br><span class="line"><span class="comment">//法一：交换前后值删除结点</span></span><br><span class="line">    <span class="keyword">if</span> (L-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (L-&gt;data == x) &#123;</span><br><span class="line">        LinkList p = L-&gt;next;</span><br><span class="line">        L-&gt;data = L-&gt;next-&gt;data;</span><br><span class="line">        L-&gt;next = p-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">        test1_Delete_x(L, x);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        test1_Delete_x(L-&gt;next, x);     <span class="comment">//这里不能先让 L=L-&gt;next，再把L代入test1_Delete_x，会导致所有结果都会消失，</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//法二：直接删除结点</span></span><br><span class="line"><span class="comment">//    LinkList p;</span></span><br><span class="line"><span class="comment">//    if (L-&gt;next == nullptr)</span></span><br><span class="line"><span class="comment">//        return;</span></span><br><span class="line"><span class="comment">//    if (L-&gt;data == x) &#123;</span></span><br><span class="line"><span class="comment">//        p = L;</span></span><br><span class="line"><span class="comment">//        L = L-&gt;next;</span></span><br><span class="line"><span class="comment">//        free(p);</span></span><br><span class="line"><span class="comment">//        test1_Delete_x(L, x);</span></span><br><span class="line"><span class="comment">//    &#125; else</span></span><br><span class="line"><span class="comment">//        test1_Delete_x(L-&gt;next, x);   //这里不能先让 L=L-&gt;next，再把L代入test1_Delete_x，会导致所有结果都会消失，</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在带头结点的单链表L中，删除所有值为x的结点，释放其空间</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test2_Delete_x</span><span class="params">(LinkList &amp;L, ElemType x)</span> </span>&#123;</span><br><span class="line"><span class="comment">//法一：由p从头扫描到尾，每一次都要连接前驱和后继</span></span><br><span class="line">    <span class="keyword">if</span> (L-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    LinkList p = L-&gt;next;</span><br><span class="line">    LinkList pre = L;   <span class="comment">//pre作为p的前驱，起连接作用</span></span><br><span class="line"><span class="comment">//    int Len = ListLength(L);</span></span><br><span class="line"><span class="comment">//    for (int i = 0; i &lt; Len; i++) &#123;</span></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;data == x) &#123;</span><br><span class="line">            LinkList q = p;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            pre-&gt;next = p;</span><br><span class="line">            <span class="built_in">free</span>(q);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pre = p;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//法二：采用尾插法建立单链表</span></span><br><span class="line"><span class="comment">//    LinkList p = L-&gt;next, r = L, q;</span></span><br><span class="line"><span class="comment">//    while (p != nullptr) &#123;</span></span><br><span class="line"><span class="comment">//        if (p-&gt;data != x) &#123;</span></span><br><span class="line"><span class="comment">//            r-&gt;next = p;</span></span><br><span class="line"><span class="comment">//            r = p;</span></span><br><span class="line"><span class="comment">//            p = p-&gt;next;</span></span><br><span class="line"><span class="comment">//        &#125; else &#123;</span></span><br><span class="line"><span class="comment">//            q = p;</span></span><br><span class="line"><span class="comment">//            p = p-&gt;next;</span></span><br><span class="line"><span class="comment">//            free(q);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//    r-&gt;next = nullptr;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//L为带头结点的单链表，实现反向输出每个结点的值</span></span><br><span class="line"><span class="comment">//本题为递归思想，也可以用逆置法，相当于尾插法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test3_Reverse_output</span><span class="params">(LinkList L)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L-&gt;next != <span class="literal">nullptr</span>)</span><br><span class="line">        test3_Reverse_output(L-&gt;next);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; L-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//带头结点的单链表L，删除其最小值的结点</span></span><br><span class="line"><span class="function">LinkList <span class="title">test4_Delete_min</span><span class="params">(LinkList &amp;L)</span> </span>&#123;</span><br><span class="line">    LinkList pre = L, p = pre-&gt;next, minpre = pre, minp = p;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;data &lt; minp-&gt;data) &#123;</span><br><span class="line">            minp = p;</span><br><span class="line">            minpre = pre;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = p;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    minpre-&gt;next = minp-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(minp);</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将一个带头结点的单链表就地逆置，即空间复杂度为O（1），即不能新建一个链表</span></span><br><span class="line"><span class="function">LinkList <span class="title">test5_Reverse_Local</span><span class="params">(LinkList &amp;L)</span> </span>&#123;</span><br><span class="line"><span class="comment">//法一：先把头结点摘下来，然后用头插法的方法从第一个结点开始吧结点插在头结点的后面</span></span><br><span class="line"><span class="comment">//    LNode *p, *r;</span></span><br><span class="line"><span class="comment">//    p = L-&gt;next;</span></span><br><span class="line"><span class="comment">//    L-&gt;next = nullptr;        //把头结点摘下</span></span><br><span class="line"><span class="comment">//    while (p != nullptr) &#123;</span></span><br><span class="line"><span class="comment">//        r = p-&gt;next;</span></span><br><span class="line"><span class="comment">//        p-&gt;next = L-&gt;next;</span></span><br><span class="line"><span class="comment">//        L-&gt;next = p;</span></span><br><span class="line"><span class="comment">//        p = r;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//    return L;</span></span><br><span class="line"><span class="comment">//法二：把各结点的指针反向指</span></span><br><span class="line">    LNode *pre, *p = L-&gt;next, *r = p-&gt;next;</span><br><span class="line">    p-&gt;next = <span class="literal">nullptr</span>;      <span class="comment">//这个要作为尾结点</span></span><br><span class="line">    <span class="keyword">while</span> (r != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        pre = p;</span><br><span class="line">        p = r;</span><br><span class="line">        r = r-&gt;next;</span><br><span class="line">        p-&gt;next = pre;</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;next = p;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使一个带头结点的单链表有序递增</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test6_increasing_order</span><span class="params">(LinkList &amp;L)</span> </span>&#123;</span><br><span class="line">    LinkList p = L-&gt;next, pre;</span><br><span class="line">    LinkList r = p-&gt;next;   <span class="comment">//r始终要为p的后继结点</span></span><br><span class="line">    p-&gt;next = <span class="literal">nullptr</span>;      <span class="comment">//从原链表断开，和头结点构造一个有序的链表</span></span><br><span class="line">    p = r;      <span class="comment">//令p指针指回还未排序的原链表</span></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        r = p-&gt;next;</span><br><span class="line">        pre = L;    <span class="comment">//pre始终要从头结点开始</span></span><br><span class="line">        <span class="keyword">while</span> (pre-&gt;next != <span class="literal">nullptr</span> &amp;&amp; p-&gt;next-&gt;data &lt; p-&gt;data)</span><br><span class="line">            pre = pre-&gt;next;</span><br><span class="line">        p-&gt;next = pre-&gt;next;</span><br><span class="line">        pre-&gt;next = p;</span><br><span class="line">        p = r;    <span class="comment">//令p指针指回还未排序的原链表</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//带头结点的无序单链表L，删除所有值在（s， e）之间的元素，不包括s和e</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test7_Delete_s_e</span><span class="params">(LinkList &amp;L, ElemType s, ElemType e)</span> </span>&#123;</span><br><span class="line">    LinkList p = L-&gt;next, pre = L;</span><br><span class="line">    <span class="keyword">if</span> (L-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;data &gt; s &amp;&amp; p-&gt;data &lt; e) &#123;</span><br><span class="line">            LinkList q = p;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            pre-&gt;next = p;</span><br><span class="line">            <span class="built_in">free</span>(q);</span><br><span class="line">            <span class="comment">//或者</span></span><br><span class="line"><span class="comment">//            pre-&gt;next = p-&gt;next;</span></span><br><span class="line"><span class="comment">//            free(p);</span></span><br><span class="line"><span class="comment">//            p = pre-&gt;next;</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pre = p;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//给定两个单链表，找出两个链表的公共结点(公共结点指某一时刻两个链表的某个节点-&gt;next会指向同一个结点，</span></span><br><span class="line"><span class="comment">// 并且之后的结点都是公共的，直到尾结点,会形成一个 Y 型)</span></span><br><span class="line"><span class="comment">//暴力法：逐个检查,时间复杂度为O（n?）</span></span><br><span class="line"><span class="comment">//线性时间复杂度法O（len1+len2）：先求出长度差，减去差后同步寻找</span></span><br><span class="line"><span class="function">LinkList <span class="title">test8_find_common_LNode</span><span class="params">(LinkList L1, LinkList L2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len1 = ListLength(L1), len2 = ListLength(L2);</span><br><span class="line">    LinkList longList, shortList;</span><br><span class="line">    <span class="keyword">int</span> dist;</span><br><span class="line">    <span class="keyword">if</span> (len1 &gt; len2) &#123;</span><br><span class="line">        longList = L1-&gt;next;</span><br><span class="line">        shortList = L2-&gt;next;</span><br><span class="line">        dist = len1 - len2;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        longList = L2-&gt;next;</span><br><span class="line">        shortList = L1-&gt;next;</span><br><span class="line">        dist = len2 - len1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (dist--)</span><br><span class="line">        longList = longList-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (longList != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (longList == shortList)</span><br><span class="line">            <span class="keyword">return</span> longList;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            longList = longList-&gt;next;</span><br><span class="line">            shortList = shortList-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LinkList L;</span><br><span class="line">    List_TailInsert(L);</span><br><span class="line"><span class="comment">//    cout &lt;&lt; &quot;输入要删除的值：&quot;;</span></span><br><span class="line"><span class="comment">//    ElemType x;</span></span><br><span class="line"><span class="comment">//    cin &gt;&gt; x;</span></span><br><span class="line"><span class="comment">//    test2_Delete_x(L, x);</span></span><br><span class="line">    test3_Reverse_output(L);</span><br><span class="line"><span class="comment">//    List_show(L);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>C++</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构_顺序表</title>
    <url>/2020/02/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%A1%BA%E5%BA%8F%E8%A1%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h5 id="数据结构顺序表的实现！"><a href="#数据结构顺序表的实现！" class="headerlink" title="数据结构顺序表的实现！"></a>数据结构顺序表的实现！</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Created by XuYiMing on 2020/2/2.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">////////////////////顺序表///////////////////////////</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> InitSize 1000        <span class="comment">//表长初始定义</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;       <span class="comment">//在此例中数据类型使用int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span>            <span class="comment">//顺序表的定义</span></span><br><span class="line">    ElemType *data;         <span class="comment">//指示动态分配数组的指针</span></span><br><span class="line">    <span class="keyword">int</span> length;             <span class="comment">//表当前长度</span></span><br><span class="line">    <span class="keyword">int</span> MaxSize;            <span class="comment">//表当前分配的最大长度</span></span><br><span class="line">&#125; SeqList;                  <span class="comment">//动态分配数组顺序表的类型定义</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">InitList</span><span class="params">(SeqList &amp;L)</span> </span>&#123;   <span class="comment">//初始化线性表，这里如果采用SeqList *L，则调用时则为 L-&gt;data</span></span><br><span class="line">    L.data = (ElemType *) <span class="built_in">malloc</span>(InitSize * <span class="keyword">sizeof</span>(ElemType));  <span class="comment">//这里数组是从0开始的，如果从1开始，则要为(InitSize+1)</span></span><br><span class="line">    <span class="keyword">if</span> (L.data == <span class="literal">nullptr</span>) &#123;    <span class="comment">//nullptr表示空指针，在C++中可以避免二义性问题</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;内存分配错误！\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    L.length = <span class="number">0</span>;</span><br><span class="line">    L.MaxSize = InitSize;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;内存分配成功！\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListInsert</span><span class="params">(SeqList &amp;L, <span class="keyword">int</span> i, ElemType e)</span> </span>&#123;     <span class="comment">//线性表的插入，在指定位置插入某值(1&lt;=i&lt;=L.length)</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; L.length + <span class="number">1</span>) &#123;      <span class="comment">//这里的i表示的是逻辑上的位置，而实际存储的是物理上的位置</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;插入位置不合理！\n&quot;</span>); <span class="comment">//判断插入的地址是否为负数或有间隔</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= L.MaxSize) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;存储空间已满！\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = L.length; j &gt;= i; j--) &#123;       <span class="comment">//平均插入时间为O(n)</span></span><br><span class="line">        L.data[j] = L.data[j - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    L.data[i - <span class="number">1</span>] = e;</span><br><span class="line">    L.length++;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListDelete</span><span class="params">(SeqList &amp;L, <span class="keyword">int</span> i, ElemType &amp;e)</span> </span>&#123;     <span class="comment">//线性表的删除，在指定位置删除某值(1&lt;=i&lt;=L.length)</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; L.length + <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;删除位置不合理！\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    e = L.data[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= L.length; j++) &#123;           <span class="comment">//平均删除时间为O(n)</span></span><br><span class="line">        L.data[j - <span class="number">1</span>] = L.data[j];</span><br><span class="line">    &#125;</span><br><span class="line">    L.length--;</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListLength</span><span class="params">(SeqList &amp;L)</span> </span>&#123;        <span class="comment">//求表长，计算元素个数</span></span><br><span class="line">    <span class="keyword">if</span> (L.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;元素个数为0&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; L.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (L.data[i]) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">locateElem</span><span class="params">(SeqList &amp;L, ElemType e)</span> </span>&#123;    <span class="comment">//按值查找逻辑下标</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; L.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (L.data[i] == e) &#123;</span><br><span class="line">            <span class="keyword">return</span> i + <span class="number">1</span>;       <span class="comment">//返回逻辑位置</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetElem</span><span class="params">(SeqList &amp;L, <span class="keyword">int</span> i)</span> </span>&#123;    <span class="comment">//按位置查找</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; L.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> L.data[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintList</span><span class="params">(SeqList L)</span> </span>&#123;    <span class="comment">//从前到后输出值</span></span><br><span class="line">    <span class="keyword">if</span> (L.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;顺序表为空&quot;</span>;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;顺序表如下：&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; L.length; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; %d&quot;</span>, L.data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////第19页综合应用题////////////////////</span></span><br><span class="line"><span class="comment">//顺序表删除最小值，把最后一个值填补最小值的位置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">test1</span><span class="params">(SeqList &amp;L, ElemType &amp;value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    value = L.data[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; L.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (L.data[i] &lt; value) &#123;</span><br><span class="line">            value = L.data[i];</span><br><span class="line">            pos = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    L.data[pos] = L.data[L.length - <span class="number">1</span>];</span><br><span class="line">    L.length--;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//把顺序表逆置，要求时间复杂度为O(1)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test2</span><span class="params">(SeqList &amp;L)</span> </span>&#123;</span><br><span class="line">    ElemType temp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; L.length / <span class="number">2</span>; i++) &#123;</span><br><span class="line">        temp = L.data[i];</span><br><span class="line">        L.data[i] = L.data[L.length - i - <span class="number">1</span>];</span><br><span class="line">        L.data[L.length - i - <span class="number">1</span>] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线性表删除所有值为x的数据元素，要求时间复杂度O(n),空间复杂度O(1)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test3</span><span class="params">(SeqList &amp;L, ElemType x)</span> </span>&#123;</span><br><span class="line"><span class="comment">//法一</span></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; L.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (L.data[i] != x) &#123;</span><br><span class="line">            L.data[k] = L.data[i];</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    L.length = k;</span><br><span class="line"><span class="comment">//法二</span></span><br><span class="line"><span class="comment">//    int k = 0, i = 0;</span></span><br><span class="line"><span class="comment">//    while (i &lt; L.length) &#123;</span></span><br><span class="line"><span class="comment">//        if (L.data[i] == x) &#123;</span></span><br><span class="line"><span class="comment">//            k++;</span></span><br><span class="line"><span class="comment">//        &#125; else &#123;</span></span><br><span class="line"><span class="comment">//            L.data[i - k] = L.data[i];</span></span><br><span class="line"><span class="comment">//            i++;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//    L.length -= k;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//有序顺序表中，删除元素的值在s和t之间的所有元素(不包括s和t)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">test4</span><span class="params">(SeqList &amp;L, ElemType s, ElemType t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">if</span> (s &gt;= t || L.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; L.length &amp;&amp; L.data[i] &lt; s; i++);</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= L.length)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (j = i; j &lt; L.length &amp;&amp; L.data[j] &lt;= t; j++);</span><br><span class="line">    <span class="keyword">for</span> (; j &lt; L.length; i++, j++)</span><br><span class="line">        L.data[i] = L.data[j];</span><br><span class="line">    L.length = i;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//顺序表中，删除元素的值在s和t之间的所有元素(包括s和t)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">test5</span><span class="params">(SeqList &amp;L, ElemType s, ElemType t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (L.length == <span class="number">0</span> || s &gt;= t)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; L.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (L.data[i] &gt;= s &amp;&amp; L.data[i] &lt;= t)</span><br><span class="line">            k++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            L.data[i - k] = L.data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    L.length -= k;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除有序顺序表中重复的元素，使其值均不同</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">test6</span><span class="params">(SeqList &amp;L)</span> </span>&#123;</span><br><span class="line"><span class="comment">//法一</span></span><br><span class="line">    <span class="keyword">if</span> (L.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i, k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; L.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (L.data[i] == L.data[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            k++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            L.data[i - k] = L.data[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    L.length -= k;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//法二</span></span><br><span class="line"><span class="comment">//    if (L.length == 0)</span></span><br><span class="line"><span class="comment">//        return 0;</span></span><br><span class="line"><span class="comment">//    int i, j;</span></span><br><span class="line"><span class="comment">//    for (i = 0, j = 1; j &lt; L.length; j++) &#123;</span></span><br><span class="line"><span class="comment">//        if (L.data[i] != L.data[j])</span></span><br><span class="line"><span class="comment">//            L.data[++i] = L.data[j];</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//    L.length = i + 1;</span></span><br><span class="line"><span class="comment">//    return 1;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//合并两个有序顺序表为一个有序顺序表</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">test7</span><span class="params">(SeqList &amp;L1, SeqList &amp;L2, SeqList &amp;L3)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L1.length + L2.length &gt; L3.MaxSize) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; L1.length &amp;&amp; j &lt; L2.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (L1.data[i] &lt;= L2.data[j]) &#123;</span><br><span class="line">            L3.data[k++] = L1.data[i++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            L3.data[k++] = L2.data[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; L1.length) &#123;</span><br><span class="line">        L3.data[k++] = L1.data[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (j &lt; L2.length) &#123;</span><br><span class="line">        L3.data[k++] = L2.data[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    L3.length = k;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将数组A[m+n]中两个序列表位置整体互换</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Reverse</span><span class="params">(ElemType A[], <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> ArraySize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right || right &gt;= ArraySize) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mid - left; i++) &#123;</span><br><span class="line">        ElemType temp = A[i];</span><br><span class="line">        A[i] = A[right - i];</span><br><span class="line">        A[right - <span class="number">1</span>] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test8</span><span class="params">(ElemType A[], <span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> ArraySize)</span> </span>&#123;</span><br><span class="line">    Reverse(A, <span class="number">0</span>, m + n - <span class="number">1</span>, ArraySize);</span><br><span class="line">    Reverse(A, <span class="number">0</span>, n - <span class="number">1</span>, ArraySize);</span><br><span class="line">    Reverse(A, n, m + n - <span class="number">1</span>, ArraySize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用最少时间的方法查找x，找到则与后继交换位置，没找到则插入且任然递增有序</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">test8</span><span class="params">(ElemType A[], ElemType x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>, high = n - <span class="number">1</span>, mid;</span><br><span class="line">    mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;       <span class="comment">//二分法</span></span><br><span class="line">        <span class="keyword">if</span> (A[mid] == x)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (A[mid] &lt; x)</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (A[mid] == x &amp;&amp; mid != n - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> t = A[mid];</span><br><span class="line">        A[mid] = A[mid + <span class="number">1</span>];</span><br><span class="line">        A[mid + <span class="number">1</span>] = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//不管是比A[0]小还是比A[n-1]大，都可以插入；因为当在A[0，n-1]之间找不到时，最后会出现low&gt;high的情况</span></span><br><span class="line">    <span class="keyword">if</span> (low &gt; high) &#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = n - <span class="number">1</span>; i &gt; high; i--) &#123;</span><br><span class="line">            A[i + <span class="number">1</span>] = A[i];</span><br><span class="line">        &#125;</span><br><span class="line">        A[i + <span class="number">1</span>] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SeqList L;</span><br><span class="line">    InitList(L);</span><br><span class="line">    <span class="keyword">int</span> i, e;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入元素个数：&quot;</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; L.length;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; L.length; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;L.data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    PrintList(L);</span><br><span class="line"><span class="comment">//    cout &lt;&lt; &quot;test6&quot;;</span></span><br><span class="line"><span class="comment">//    test6(L);</span></span><br><span class="line"><span class="comment">//    PrintList(L);</span></span><br><span class="line"><span class="comment">//    cout &lt;&lt; &quot;请输入插入的位置和插入的元素：&quot;;</span></span><br><span class="line"><span class="comment">//    scanf(&quot;%d%d&quot;, &amp;i, &amp;e);</span></span><br><span class="line"><span class="comment">//    ListInsert(L, i, e);</span></span><br><span class="line"><span class="comment">//    PrintList(L);</span></span><br><span class="line"><span class="comment">//    cout &lt;&lt; &quot;请输入删除的位置：&quot;;</span></span><br><span class="line"><span class="comment">//    scanf(&quot;%d&quot;, &amp;i);</span></span><br><span class="line"><span class="comment">//    ListDelete(L, i, e);</span></span><br><span class="line"><span class="comment">//    cout &lt;&lt; e &lt;&lt; &quot;被删除了!&quot;;</span></span><br><span class="line"><span class="comment">//    PrintList(L);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>C++</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构_队列</title>
    <url>/2020/03/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h5 id="数据结构队列的实现！"><a href="#数据结构队列的实现！" class="headerlink" title="数据结构队列的实现！"></a>数据结构队列的实现！</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by XuYiMing on 2020/2/21.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElementType;</span><br><span class="line"></span><br><span class="line"><span class="comment">//*****************顺序/循环队列******************</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    ElementType data[MaxSize];</span><br><span class="line">    <span class="keyword">int</span> front, rear;</span><br><span class="line">&#125; SqQueue;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitQueue</span><span class="params">(SqQueue &amp;Q)</span> </span>&#123;        <span class="comment">//初始化</span></span><br><span class="line">    Q.rear = Q.front;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">(SqQueue Q)</span> </span>&#123;       <span class="comment">//判空</span></span><br><span class="line">    <span class="keyword">if</span> (Q.front == Q.rear)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">EnQueue</span><span class="params">(SqQueue &amp;Q, ElementType x)</span> </span>&#123;       <span class="comment">//入队</span></span><br><span class="line">    <span class="keyword">if</span> ((Q.rear + <span class="number">1</span>) % MaxSize == Q.front)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    Q.data[Q.rear] = x;</span><br><span class="line">    Q.rear = (Q.rear + <span class="number">1</span>) % MaxSize;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DeQueue</span><span class="params">(SqQueue &amp;Q, ElementType &amp;x)</span> </span>&#123;      <span class="comment">//出队</span></span><br><span class="line">    <span class="keyword">if</span> (Q.rear == Q.front)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    x = Q.data[Q.front];</span><br><span class="line">    Q.front = (Q.front + <span class="number">1</span>) % MaxSize;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//*******************链式存储队列****************</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span> &#123;</span></span><br><span class="line">    ElementType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; LinkNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    LinkNode *rear, *front;</span><br><span class="line">&#125; LinkQueue;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitLinkQueue</span><span class="params">(LinkQueue &amp;Q)</span> </span>&#123;</span><br><span class="line">    Q.front = Q.rear = (LinkNode *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));       <span class="comment">//建立头结点</span></span><br><span class="line">    Q.front-&gt;next = <span class="literal">nullptr</span>;        <span class="comment">//初始化为空</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsLinkEmpty</span><span class="params">(LinkQueue Q)</span> </span>&#123;     <span class="comment">//判空</span></span><br><span class="line">    <span class="keyword">if</span> (Q.front == Q.rear)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EnLinkQueue</span><span class="params">(LinkQueue &amp;Q, ElementType x)</span> </span>&#123;         <span class="comment">//入队</span></span><br><span class="line">    LinkNode *s = (LinkNode *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));</span><br><span class="line">    s-&gt;data = x;</span><br><span class="line">    s-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    Q.rear-&gt;next = s;</span><br><span class="line">    Q.rear = s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DeLinkQueue</span><span class="params">(LinkQueue &amp;Q, ElementType &amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Q.rear == Q.front)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    LinkNode *p = Q.front-&gt;next;</span><br><span class="line">    x = p-&gt;data;</span><br><span class="line">    Q.front-&gt;next = p-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> (Q.rear == p)</span><br><span class="line">        Q.rear = Q.front;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>C++</tag>
        <tag>C</tag>
      </tags>
  </entry>
</search>
