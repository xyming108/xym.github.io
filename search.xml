<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>mysql学习笔记Day2</title>
    <url>/2021/03/18/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0Day2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>[TOC]</p>
<h1 id="Day2"><a href="#Day2" class="headerlink" title="Day2"></a>Day2</h1><h3 id="1、排序查询"><a href="#1、排序查询" class="headerlink" title="1、排序查询"></a><strong>1、排序查询</strong></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#语法</span><br><span class="line">select</span><br><span class="line">	要查询的东西</span><br><span class="line">from</span><br><span class="line">	表</span><br><span class="line">where </span><br><span class="line">	条件</span><br><span class="line"></span><br><span class="line">order by 排序的字段|表达式|函数|别名 【asc|desc】</span><br><span class="line">(默认升序)</span><br></pre></td></tr></table></figure>
<h4 id="实践代码"><a href="#实践代码" class="headerlink" title="实践代码"></a>实践代码</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from employees order by salary desc;</span><br><span class="line">select * from employees order by salary asc;</span><br><span class="line"></span><br><span class="line">select * </span><br><span class="line">from employees</span><br><span class="line">where department_id &gt;&#x3D; 90</span><br><span class="line">order by hiredate asc;</span><br><span class="line"></span><br><span class="line">#按年薪的高低显示员工的信息和年薪（按表达式排序）</span><br><span class="line">select *, salary*12*(1+ifnull(commission_pct, 0)) as 年薪</span><br><span class="line">from employees</span><br><span class="line">#order by salary*12*(1+ifnull(commission_pct, 0)) desc;</span><br><span class="line">order by 年薪 desc;</span><br><span class="line"></span><br><span class="line">#按姓名长度显示员工的姓名和工资【按函数排序】</span><br><span class="line">select length(last_name) as 字节长度, last_name, salary</span><br><span class="line">from employees</span><br><span class="line">order by 字节长度 desc;</span><br><span class="line"></span><br><span class="line">#查询员工信息，先按工资什序，再按员工编号降序【按多个字段排序】</span><br><span class="line">select *</span><br><span class="line">from employees</span><br><span class="line">order by salary asc, employee_id desc;</span><br></pre></td></tr></table></figure>
<h3 id="2、常见函数"><a href="#2、常见函数" class="headerlink" title="2、常见函数"></a><strong>2、常见函数</strong></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#语法</span><br><span class="line">select 函数名()</span><br><span class="line">【from 表】</span><br></pre></td></tr></table></figure>
<h4 id="单行函数"><a href="#单行函数" class="headerlink" title="单行函数"></a><strong>单行函数</strong></h4><h5 id="字符函数"><a href="#字符函数" class="headerlink" title="字符函数"></a>字符函数</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*concat拼接</span><br><span class="line">substr截取子串</span><br><span class="line">upper转换成大写</span><br><span class="line">lower转换成小写</span><br><span class="line">trim去前后指定的空格和字符</span><br><span class="line">ltrim去左边空格</span><br><span class="line">rtrim去右边空格</span><br><span class="line">replace替换</span><br><span class="line">lpad左填充</span><br><span class="line">rpad右填充</span><br><span class="line">instr返回子串第一次出现的索引</span><br><span class="line">length 获取字节个数</span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">select length(&#39;length&#39;);</span><br><span class="line">select upper(&#39;select&#39;);</span><br><span class="line">select lower(&#39;WERTY&#39;);</span><br><span class="line">select concat(upper(last_name), lower(first_name)) 姓名 from employees;</span><br><span class="line">select substr(&#39;李莫愁神雕侠侣&#39;, 4) as aa;	#索引从1开始</span><br><span class="line">select substr(&#39;李莫愁神雕侠侣&#39;, 4, 2) as aa;	#后面的2表示字符长度</span><br><span class="line">select concat(substr(last_name, 1, 1), &#39;_&#39;, lower(substr(last_name, 2))) aa from employees;</span><br><span class="line">select instr(&#39;倚天屠龙记屠龙记&#39;, &#39;屠龙记&#39;) as aa;  #找不到返回0</span><br><span class="line">select length(trim(&#39;     子怡     &#39;)) as aa;</span><br><span class="line">select trim(&#39;a&#39; from &#39;aaa子怡aaaa&#39;) as aa;</span><br><span class="line">select lpad(&#39;你好&#39;, 10, &#39;*&#39;) output;</span><br><span class="line">select rpad(&#39;你好&#39;, 10, &#39;*&#39;) output;</span><br><span class="line">select replace(&#39;张无忌_周芷若_周芷若_周芷若&#39;, &#39;周芷若&#39;, &#39;赵敏&#39;) aa;</span><br></pre></td></tr></table></figure>
<h5 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*round 四舍五入</span><br><span class="line">rand 随机数</span><br><span class="line">floor向下取整</span><br><span class="line">ceil向上取整</span><br><span class="line">mod取余</span><br><span class="line">truncate截断*&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">select round(-1.35);</span><br><span class="line">select round(1.5664, 2);</span><br><span class="line">select ceil(1.564);		#2</span><br><span class="line">select ceil(1);		#1</span><br><span class="line">select floor(1.564);	#1</span><br><span class="line">select floor(1);	#1</span><br><span class="line">select truncate(1.6932, 2);</span><br><span class="line">select mod(10, 3);		#1</span><br><span class="line">select mod(-10, 3);		#-1</span><br><span class="line">select mod(10, -3);  	#1</span><br><span class="line">select mod(-10, -3);	#-1  总结：符号和被除数保持一致</span><br></pre></td></tr></table></figure>


<h5 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*now当前系统日期+时间</span><br><span class="line">curdate当前系统日期</span><br><span class="line">curtime当前系统时间</span><br><span class="line">datediff(date1, date2)日期之差date1-date2</span><br><span class="line">str_to_date 将字符转换成日期</span><br><span class="line">date_format将日期转换成字符</span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">select now();</span><br><span class="line">select curdate();</span><br><span class="line">select curtime();</span><br><span class="line">select year(now()) 年, month(now()) 月;</span><br><span class="line">select year(&#39;1998-8-18&#39;) 年;</span><br><span class="line">select monthname(now()) 月;</span><br><span class="line">select datediff(now(), &#39;1998-10-8&#39;);</span><br><span class="line"></span><br><span class="line">#str_to_data：将日期格式的字符转换成指定格式日期</span><br><span class="line">select str_to_date(&#39;1992-4-3&#39;, &#39;%Y-%m-%d&#39;) output;</span><br><span class="line">#查询入职日期为1992-4-3的员工信息</span><br><span class="line">select * from employees where hiredate&#x3D;&#39;1992-4-3&#39;;</span><br><span class="line">select * from employees where hiredate&#x3D;str_to_date(&#39;4-3-1992&#39;, &#39;%m-%d-%Y&#39;);</span><br><span class="line"></span><br><span class="line">#date-format：将日期转换成字符</span><br><span class="line">select date_format(now(), &#39;%Y年%m月%d日&#39;);</span><br><span class="line">#查询有奖金的员工名和入职日期</span><br><span class="line">select last_name, date_format(hiredate, &#39;%m月&#x2F;%d日 %Y年&#39;) 入职日期</span><br><span class="line">from employees</span><br><span class="line">where commission_pct is not null;</span><br></pre></td></tr></table></figure>
<h5 id="其他函数"><a href="#其他函数" class="headerlink" title="其他函数"></a>其他函数</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*version版本</span><br><span class="line">database当前库</span><br><span class="line">user当前连接用户*&#x2F;</span><br><span class="line"></span><br><span class="line">select version();</span><br><span class="line">select database();</span><br><span class="line">select user();</span><br></pre></td></tr></table></figure>
<h5 id="流程控制函数"><a href="#流程控制函数" class="headerlink" title="流程控制函数"></a>流程控制函数</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*if 处理双分支</span><br><span class="line">case语句 处理多分支</span><br><span class="line">		情况1：处理等值判断</span><br><span class="line">		情况2：处理条件判断*&#x2F;</span><br><span class="line">		</span><br><span class="line">select if(10 &gt; 5, &#39;大&#39;, &#39;小&#39;) aa;</span><br><span class="line">select last_name, commission_pct,  if(commission_pct is null, &#39;没奖金&#39;, &#39;有奖金&#39;) aa</span><br><span class="line">from employees;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line">case的使用法一：</span><br><span class="line"></span><br><span class="line">case 要判断的字段或表达式</span><br><span class="line">when 条件1 then 要显示的值1或语句1</span><br><span class="line">when 条件2 then 要显示的值2或语句2</span><br><span class="line">when 条件3 then 要显示的值3或语句3</span><br><span class="line">......</span><br><span class="line">else 要显示的值n或语句n</span><br><span class="line">end 【as 别名】</span><br><span class="line">*&#x2F;</span><br><span class="line">select salary 原始工资, department_id,</span><br><span class="line">case department_id</span><br><span class="line">when 30 then salary*1.1</span><br><span class="line">when 40 then salary*1.2</span><br><span class="line">when 50 then salary*1.3</span><br><span class="line">else salary</span><br><span class="line">end as 新工资</span><br><span class="line">from employees;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line">case的使用法二：</span><br><span class="line"></span><br><span class="line">case </span><br><span class="line">when 条件1 then 要显示的值1或语句1</span><br><span class="line">when 条件2 then 要显示的值2或语句2</span><br><span class="line">when 条件3 then 要显示的值3或语句3</span><br><span class="line">......</span><br><span class="line">else 要显示的值n或语句n</span><br><span class="line">end 【as 别名】</span><br><span class="line">*&#x2F;</span><br><span class="line">select salary 原始工资, department_id,</span><br><span class="line">case</span><br><span class="line">when salary&gt;20000 then &#39;A&#39;</span><br><span class="line">when salary&gt;15000 then &#39;B&#39;</span><br><span class="line">when salary&gt;10000 then &#39;C&#39;</span><br><span class="line">else &#39;D&#39;</span><br><span class="line">end as 工资级别</span><br><span class="line">from employees;</span><br></pre></td></tr></table></figure>
<h4 id="分组函数"><a href="#分组函数" class="headerlink" title="分组函数"></a><strong>分组函数</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*sum 求和</span><br><span class="line">max 最大值</span><br><span class="line">min 最小值</span><br><span class="line">avg 平均值</span><br><span class="line">count 计数</span><br><span class="line"></span><br><span class="line">特点：</span><br><span class="line">	1、以上五个分组函数都忽略null值且不计入总数，</span><br><span class="line">	2、sum和avg一般用于处理数值型</span><br><span class="line">		max、min、count可以处理任何数据类型</span><br><span class="line">    3、都可以搭配distinct使用，用于统计去重后的结果</span><br><span class="line">	4、count的参数可以支持：字段、*、常量值，一般放1</span><br><span class="line">		count(*)，计算行数时null的也会包含进去，效率高，最常用</span><br><span class="line">		count(1)，计算行数时null的也会包含进去，效率高</span><br><span class="line">		count(字段名)，得到的结果将是除去值为null和重复数据后的结果，效率低</span><br><span class="line">	5、和分组函数一同查询的字段要求是group by后的字段</span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">select sum(salary) from employees;</span><br><span class="line">select max(salary) from employees;</span><br><span class="line">select min(salary) from employees;</span><br><span class="line">select avg(salary) from employees;</span><br><span class="line">select count(salary) from employees;</span><br><span class="line">#组合</span><br><span class="line">select sum(salary), max(salary), round(avg(salary)) from employees;</span><br><span class="line">#查询部门编号为90的员工个数</span><br><span class="line">select count(*) as 个数</span><br><span class="line">from employees</span><br><span class="line">where department_id &#x3D; 90;</span><br></pre></td></tr></table></figure>
<h5 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*语法：</span><br><span class="line">	select 查询的字段，分组函数</span><br><span class="line">	from 表</span><br><span class="line">	【where 筛选条件】</span><br><span class="line">	group by 分组的字段</span><br><span class="line">	【order by 子句】</span><br><span class="line">*&#x2F;</span><br><span class="line">&#x2F;*</span><br><span class="line">特点：</span><br><span class="line">	1、可以按单个字段分组</span><br><span class="line">	2、和分组函数一同查询的字段最好是分组后的字段</span><br><span class="line">	3、分组筛选</span><br><span class="line">			            针对的表	         位置			    关键字</span><br><span class="line">	      分组前筛选：	原始表		      group by的前面		where</span><br><span class="line">	      分组后筛选：	分组后的结果集	   group by的后面		 having</span><br><span class="line"></span><br><span class="line">	4、可以按多个字段分组，字段之间用逗号隔开</span><br><span class="line">	5、可以支持排序</span><br><span class="line">	6、having后可以支持别名</span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#查询每个工种的最高工资</span><br><span class="line">select max(salary), job_id</span><br><span class="line">from employees</span><br><span class="line">group by job_id;</span><br><span class="line"></span><br><span class="line">#查询每个位置的部门个数</span><br><span class="line">select count(*), location_id</span><br><span class="line">from departments</span><br><span class="line">group by location_id;</span><br><span class="line"></span><br><span class="line">#查询邮箱中包含a字符的，每个部门的平均工资</span><br><span class="line">select avg(salary), department_id, email</span><br><span class="line">from employees</span><br><span class="line">where email like &#39;%a%&#39;</span><br><span class="line">group by department_id;</span><br><span class="line"></span><br><span class="line">#查询有奖金的每个领导手下员工的最高工资</span><br><span class="line">select max(salary), manager_id</span><br><span class="line">from employees</span><br><span class="line">where commission_pct is not null</span><br><span class="line">group by manager_id;</span><br><span class="line"></span><br><span class="line">#查询哪个部门的员工个数大于2</span><br><span class="line">select count(*), department_id</span><br><span class="line">from employees</span><br><span class="line">group by department_id</span><br><span class="line">having count(*) &gt; 2;</span><br><span class="line"></span><br><span class="line">#查询每个工种有奖金的员工的最高工资&gt;12000的工种编号和最高工资</span><br><span class="line">select job_id, max(salary)</span><br><span class="line">from employees</span><br><span class="line">where commission_pct is not null</span><br><span class="line">group by job_id</span><br><span class="line">having max(salary) &gt; 12000;</span><br><span class="line"></span><br><span class="line">#查询领导编号大于102的每个领导手下的最低工资&gt;5000的领导编号是哪个，以及其最低工资</span><br><span class="line">select manager_id, min(salary)</span><br><span class="line">from employees</span><br><span class="line">where manager_id &gt; 102</span><br><span class="line">group by manager_id</span><br><span class="line">having min(salary) &gt; 5000;</span><br><span class="line"></span><br><span class="line">#按员工姓名的长度分组，查询每一组的员工个数，筛选员工个数&gt;5的有哪些</span><br><span class="line">select length(concat(first_name, last_name)) 长度, count(*)</span><br><span class="line">from employees</span><br><span class="line">group by length(concat(first_name, last_name))</span><br><span class="line">having count(*) &gt; 5;</span><br><span class="line"></span><br><span class="line">#查询每个部门，每个工种员工的平均工资</span><br><span class="line">select avg(salary), department_id, job_id</span><br><span class="line">from employees</span><br><span class="line">group by department_id, job_id;</span><br><span class="line"></span><br><span class="line">#查询每个部门，每个工种员工的平均工资，平均工资大于10000，并且按平均工资的高低显示出来</span><br><span class="line">select avg(salary), department_id, job_id</span><br><span class="line">from employees</span><br><span class="line">where department_id is not null</span><br><span class="line">group by department_id, job_id</span><br><span class="line">having avg(salary) &gt; 10000</span><br><span class="line">order by avg(salary) desc;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql学习笔记Day1</title>
    <url>/2021/03/18/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0Day1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>[TOC]</p>
<h1 id="Day1"><a href="#Day1" class="headerlink" title="Day1"></a>Day1</h1><h3 id="1、数据库的相关概念"><a href="#1、数据库的相关概念" class="headerlink" title="1、数据库的相关概念"></a>1、<strong>数据库的相关概念</strong></h3><p>一、数据库的好处</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.持久化数据到本地</span><br><span class="line">2.可以实现结构化查询，方便管理</span><br></pre></td></tr></table></figure>
<p>二、常见概念</p>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、<span class="built_in">DB</span>：数据库，保存一组有组织的数据的容器</span><br><span class="line"><span class="number">2</span>、DBMS：数据库管理系统，又称为数据库软件（产品），用于管理<span class="built_in">DB</span>中的数据</span><br><span class="line"><span class="number">3</span>、S<span class="symbol">QL:</span> 结构化查询语言，用于和DBMS通信的语言</span><br></pre></td></tr></table></figure>
<p>三、数据库存储数据的特点</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、将数据放到表中，表再放到库中</span><br><span class="line"><span class="number">2</span>、一个数据库中可以有多个表，每个表都有一个的名字，用来标识自己。表名具有唯一性。</span><br><span class="line"><span class="number">3</span>、表具有一些特性，这些特性定义了数据在表中如何存储，类似<span class="keyword">java中“类”的设计。</span></span><br><span class="line"><span class="keyword">4、表由列组成，我们也称为字段。所有表都是由一个或多个列组成的，每一列类似java </span>中的”属性”</span><br><span class="line"><span class="number">5</span>、表中的数据是按行存储的，每一行类似于<span class="keyword">java中的“对象”</span></span><br></pre></td></tr></table></figure>
<h3 id="2、MySQL的简单使用"><a href="#2、MySQL的简单使用" class="headerlink" title="2、MySQL的简单使用"></a>2、<strong>MySQL的简单使用</strong></h3><p>一、MySQL的启动和停止</p>
<figure class="highlight dos"><table><tr><td class="code"><pre><span class="line">启动：<span class="built_in">net</span> <span class="built_in">start</span> 服务名（例如：<span class="built_in">net</span> <span class="built_in">start</span> mysql80）</span><br><span class="line"></span><br><span class="line">停止：<span class="built_in">net</span> stop 服务名（例如：<span class="built_in">net</span> stop mysql80）</span><br></pre></td></tr></table></figure>
<p>二、MySQL的登录和退出</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">登录：mysql -h 主机名 -P 端口号 -u 用户名 -p密码 </span><br><span class="line">	（注意：-p和密码中间不能加空格）</span><br><span class="line">	（例如：mysql 【-h localhost P <span class="number">3306</span>】 -u root -p564445 ，若是登录本地的，【】内的可以不写）</span><br><span class="line"></span><br><span class="line">退出：<span class="keyword">exit</span> 或 ctl+c</span><br></pre></td></tr></table></figure>
<h3 id="3、MySQL常见命令"><a href="#3、MySQL常见命令" class="headerlink" title="3、MySQL常见命令"></a>3、<strong>MySQL常见命令</strong></h3><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> databases； 查看所有的数据库</span><br><span class="line">use 库名； 打开指定 的库</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">tables</span> ; 显示库中的所有表</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">tables</span> <span class="keyword">from</span> 库名;显示指定库中的所有表</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名(</span><br><span class="line">	字段名 字段类型,	</span><br><span class="line">	字段名 字段类型</span><br><span class="line">); 创建表</span><br><span class="line"></span><br><span class="line"><span class="keyword">desc</span> 表名; 查看指定表的结构</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> 表名;显示表中的所有数据</span><br></pre></td></tr></table></figure>
<h3 id="4、基础、条件查询"><a href="#4、基础、条件查询" class="headerlink" title="4、基础、条件查询"></a>4、<strong>基础、条件查询</strong></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select 字段名 from 表名;</span><br><span class="line">select 字段名1，字段名2，...... from 表名;</span><br><span class="line">select * from 表名;</span><br><span class="line">select 常量值;（注意：字符型和日期型的常量值要用单引号括起来，数值型不需要）</span><br><span class="line">select 函数名;</span><br><span class="line">select 表达式;</span><br><span class="line">select 数值+数值; 	&#x2F;*结果为数值*&#x2F;</span><br><span class="line">select 字符+数值;	&#x2F;*试图将字符转换成数值，转换成功则继续运算，转换不成功则把字符当成成0再运算*&#x2F;</span><br><span class="line">select null+值;	&#x2F;*结果都为null*&#x2F;</span><br><span class="line"></span><br><span class="line">#别名</span><br><span class="line">select 字段名 as 别名 from 表名;</span><br><span class="line">select 字段名 别名 from 表名;	&#x2F;*可直接用空格代替as*&#x2F;</span><br><span class="line"></span><br><span class="line">#去重</span><br><span class="line">select distinct 字段名 from 表名;</span><br><span class="line"></span><br><span class="line">#concat函数</span><br><span class="line">select concat（字符1，字符2，......） from 表名;</span><br><span class="line"></span><br><span class="line">#ifnull函数</span><br><span class="line">#判断某字段或表达式是否为null，如果为null，返回指定的值（比如指定0），否则返回原本的值</span><br><span class="line">select ifnull(字符, 0) from 表名;</span><br><span class="line"></span><br><span class="line">#isnull</span><br><span class="line">#判断某字段或表达式是否为null，是则返回1，不是则返回0</span><br><span class="line">select 字符1 from 表名 where 字符1 is null;</span><br><span class="line">select 字符1 from 表名 where 字符1 is not null;</span><br></pre></td></tr></table></figure>
<h4 id="条件运算符"><a href="#条件运算符" class="headerlink" title="条件运算符"></a>条件运算符</h4><pre><code>&gt;
&lt;
&gt;= 
&lt;= 
= ，&lt;=&gt; 安全等于
!= ，&lt;&gt;
</code></pre>
<h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h4><pre><code>and（&amp;&amp;）:两个条件如果同时成立，结果为true，否则为false
or(||)：两个条件只要有一个成立，结果为true，否则为false
not(!)：如果条件成立，则not后为false，否则为true
</code></pre>
<h4 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h4><pre><code>like 
between and
in
is null
</code></pre>
<h4 id="实践代码"><a href="#实践代码" class="headerlink" title="实践代码"></a>实践代码</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">use myemployees;</span><br><span class="line"></span><br><span class="line">select * from employees;</span><br><span class="line">select first_name from employees; </span><br><span class="line">select first_name as hhh from employees; </span><br><span class="line">select first_name hhh from employees; </span><br><span class="line">select distinct department_id from employees; </span><br><span class="line">select ifnull(commission_pct, 0)  as 奖金率, commission_pct from employees;</span><br><span class="line">select concat(first_name,&#39;___&#39; ,last_name,&#39;___&#39;,ifnull(commission_pct, 0)) as output from employees; </span><br><span class="line">select 100;</span><br><span class="line">select &#39;xym&#39;;</span><br><span class="line">select 100*20 as resulet;</span><br><span class="line">select version();</span><br><span class="line"></span><br><span class="line">#------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line">&#x2F;*</span><br><span class="line">select </span><br><span class="line">		查询列表</span><br><span class="line">from</span><br><span class="line">		表名</span><br><span class="line">where</span><br><span class="line">		筛选条件;</span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">select * from employees where salary&gt;12000;</span><br><span class="line">select last_name, department_id from employees where department_id &lt;&gt; 90;</span><br><span class="line"></span><br><span class="line">select last_name, salary, commission_pct </span><br><span class="line">from employees </span><br><span class="line">where salary &gt;&#x3D; 10000 and salary &lt;&#x3D; 20000;</span><br><span class="line"></span><br><span class="line">select *</span><br><span class="line">from employees</span><br><span class="line">where not(department_id &lt; 90 or department_id&gt;110) </span><br><span class="line">	  or salary &gt; 15000;</span><br><span class="line"></span><br><span class="line">&#x2F;*通配符：%任意多个字符</span><br><span class="line">		  _任意单个字符</span><br><span class="line">*&#x2F;</span><br><span class="line">select * from employees where last_name like &#39;%a%&#39;;</span><br><span class="line">select * from employees where last_name like &#39;_e_l&#39;;</span><br><span class="line"></span><br><span class="line">select * </span><br><span class="line">from employees </span><br><span class="line">where last_name </span><br><span class="line">like &#39;_$_%&#39; escape &#39;$&#39;;*&#x2F;  &#x2F;*查询第二个字符为_的员工，转义*&#x2F;</span><br><span class="line"></span><br><span class="line">select * </span><br><span class="line">from employees </span><br><span class="line">where employee_id </span><br><span class="line">between 100 and 120;  &#x2F;*包含临界值（闭区间），不能颠倒大小*&#x2F;</span><br><span class="line"></span><br><span class="line">select last_name, job_id</span><br><span class="line">from employees </span><br><span class="line">#where job_id&#x3D;&#39;IT_PROT&#39; or  job_id&#x3D; &#39;AD_VP&#39; or job_id &#x3D; &#39;AD_PRES&#39;;</span><br><span class="line">where job_id in(&#39;IT_PROT&#39;,&#39;AD_VP&#39;,&#39;AD_PRES&#39;)</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line">is null:仅可以判断 null</span><br><span class="line">&lt;&#x3D;&gt;:既可以判断 null，又可以判断数值</span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">select last_name, commission_pct</span><br><span class="line">from employees </span><br><span class="line">#where commission_pct is null;</span><br><span class="line">where commission_pct is not null;</span><br><span class="line"></span><br><span class="line">select last_name, commission_pct</span><br><span class="line">from employees </span><br><span class="line">where commission_pct &lt;&#x3D;&gt; null;   &#x2F;*安全等于*&#x2F;</span><br><span class="line"></span><br><span class="line">select last_name, commission_pct, salary</span><br><span class="line">from employees </span><br><span class="line">where salary &lt;&#x3D;&gt; 12000;   &#x2F;*安全等于*&#x2F;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql学习笔记Day3</title>
    <url>/2021/03/18/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0Day3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>[TOC]</p>
<h1 id="Day3"><a href="#Day3" class="headerlink" title="Day3"></a>Day3</h1><h3 id="1、多表连接查询"><a href="#1、多表连接查询" class="headerlink" title="1、多表连接查询"></a><strong>1、多表连接查询</strong></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">按功能分类：</span><br><span class="line">	内连接：</span><br><span class="line">		等值连接</span><br><span class="line">		非等值连接</span><br><span class="line">		自连接</span><br><span class="line">	外连接：</span><br><span class="line">		左外连接</span><br><span class="line">		右外连接</span><br><span class="line">		全外连接</span><br><span class="line">	交叉连接</span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure>
<h4 id="内连接（sql92语法）"><a href="#内连接（sql92语法）" class="headerlink" title="内连接（sql92语法）"></a>内连接（sql92语法）</h4><h5 id="等值连接"><a href="#等值连接" class="headerlink" title="等值连接"></a>等值连接</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#等值连接</span><br><span class="line">#查询员工名和对应的部门名</span><br><span class="line">select last_name, department_name</span><br><span class="line">from employees, departments</span><br><span class="line">where employees.&#96;department_id&#96; &#x3D; departments.&#96;department_id&#96;;</span><br><span class="line"></span><br><span class="line">#为表起别名：提高语句的简洁度，区分重名字段（注意：起了别名后不能用原来的表名）</span><br><span class="line">#查询员工名、工种号、工种名</span><br><span class="line">select last_name, e.job_id, job_title</span><br><span class="line">from employees as e, jobs as j</span><br><span class="line">where e.job_id &#x3D; j.job_id;</span><br><span class="line"></span><br><span class="line">#查询有奖金的员工名、部门名</span><br><span class="line">select last_name, department_name, commission_pct</span><br><span class="line">from employees e, departments d</span><br><span class="line">where e.department_id &#x3D; d.department_id and e.commission_pct is not null;</span><br><span class="line"></span><br><span class="line">#查询城市名中第二个字符为o的部门名和城市名</span><br><span class="line">select department_name, city</span><br><span class="line">from departments d, locations l</span><br><span class="line">where d.location_id &#x3D; l.location_id and city like &#39;_o%&#39;;</span><br><span class="line"></span><br><span class="line">#查询每个城市的部门个数</span><br><span class="line">select count(*) 个数, city</span><br><span class="line">from departments d, locations l</span><br><span class="line">where d.location_id &#x3D; l.location_id</span><br><span class="line">group by city;</span><br><span class="line"></span><br><span class="line">#查询每个工种的工种名和员工的个数，并且按员工个数降序</span><br><span class="line">select job_title, count(*)</span><br><span class="line">from employees e, jobs j</span><br><span class="line">where e.job_id &#x3D; j.job_id</span><br><span class="line">group by job_title</span><br><span class="line">order by count(*) desc;</span><br><span class="line"></span><br><span class="line">#三表连接</span><br><span class="line">#查询员工名、部门名、所在城市</span><br><span class="line">select last_name, department_name, city</span><br><span class="line">from employees e, departments d, locations l</span><br><span class="line">where e.department_id &#x3D; d.department_id</span><br><span class="line">and d.location_id &#x3D; l.location_id;</span><br></pre></td></tr></table></figure>
<h5 id="非等值连接"><a href="#非等值连接" class="headerlink" title="非等值连接"></a>非等值连接</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#查询员工的工资和工资级别</span><br><span class="line">select salary, grade_level</span><br><span class="line">from employees e, job_grades j</span><br><span class="line">where salary between j.lowest_sal and j.highest_sal;</span><br></pre></td></tr></table></figure>
<h5 id="自连接"><a href="#自连接" class="headerlink" title="自连接"></a>自连接</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#查询员工名和其对应的上级的名称（查员工名要访问一次表，查领导名要再访问一次同一张表）</span><br><span class="line">select e.employee_id, e.last_name, m.manager_id, m.last_name</span><br><span class="line">from employees e, employees m</span><br><span class="line">where m.manager_id &#x3D; e.employee_id;</span><br></pre></td></tr></table></figure>
<h3 id="2、sql99语法"><a href="#2、sql99语法" class="headerlink" title="2、sql99语法"></a><strong>2、sql99语法</strong></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*语法</span><br><span class="line">select 查询列表</span><br><span class="line">from 表1 别名</span><br><span class="line">【inner|left outer|right outer|cross】 表2 别名 on 连接条件2</span><br><span class="line">【inner|left outer|right outer|cross】 表3 别名 on 连接条件3</span><br><span class="line">【where 筛选条件】</span><br><span class="line">【group by 分组】</span><br><span class="line">【having 分组后的筛选条件】</span><br><span class="line">【order by 排序列表】</span><br><span class="line"></span><br><span class="line">分类：</span><br><span class="line">	内连接：inner</span><br><span class="line">	外连接：</span><br><span class="line">		左外连接：left 【outer】</span><br><span class="line">		右外连接：right 【outer】</span><br><span class="line">		全外连接：full 【outer】</span><br><span class="line">	交叉连接：cross</span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*语法</span><br><span class="line"></span><br><span class="line">select 查询列表</span><br><span class="line">from 表1 别名</span><br><span class="line">inner join 表2 别名</span><br><span class="line">on 连接条件</span><br><span class="line"></span><br><span class="line">分类：</span><br><span class="line">	等值</span><br><span class="line">	非等值</span><br><span class="line">	自连接</span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure>
<h5 id="等值连接-1"><a href="#等值连接-1" class="headerlink" title="等值连接"></a>等值连接</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#查询员工名、部门名</span><br><span class="line">select last_name, department_name</span><br><span class="line">from employees e</span><br><span class="line">inner join departments d</span><br><span class="line">on e.department_id &#x3D; d.department_id;</span><br><span class="line"></span><br><span class="line">#查询名字中包含e的员工名和工种名</span><br><span class="line">select last_name, job_title</span><br><span class="line">from employees e</span><br><span class="line">inner join jobs j</span><br><span class="line">on e.job_id &#x3D; j.job_id</span><br><span class="line">where e.last_name like &#39;%e%&#39;;</span><br><span class="line"></span><br><span class="line">#查询部门个数 &gt; 3 的城市名和部门个数</span><br><span class="line">select city, count(*) </span><br><span class="line">from departments d</span><br><span class="line">inner join locations l</span><br><span class="line">on l.location_id &#x3D; d.location_id</span><br><span class="line">group by city</span><br><span class="line">having count(*) &gt; 3;</span><br><span class="line"></span><br><span class="line">#查询员工名、部门名、工种名，并按部门名降序</span><br><span class="line">select last_name, department_name, job_title</span><br><span class="line">from employees e</span><br><span class="line">inner join departments d on d.department_id &#x3D; e.department_id</span><br><span class="line">inner join jobs j on j.job_id &#x3D; e.job_id</span><br><span class="line">order by department_name desc;</span><br></pre></td></tr></table></figure>
<h5 id="非等值连接-1"><a href="#非等值连接-1" class="headerlink" title="非等值连接"></a>非等值连接</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#查询员工的工资级别</span><br><span class="line">select salary, grade_level</span><br><span class="line">from employees e</span><br><span class="line">join job_grades g</span><br><span class="line">on e.salary between g.lowest_sal and g.highest_sal;</span><br><span class="line"></span><br><span class="line">#查询每个工资级别的个数&gt;20的个数，并且按工资级别降序</span><br><span class="line">select count(*), grade_level</span><br><span class="line">from employees e</span><br><span class="line">join job_grades g</span><br><span class="line">on e.salary between g.lowest_sal and g.highest_sal</span><br><span class="line">group by grade_level</span><br><span class="line">having count(*) &gt; 20</span><br><span class="line">order by grade_level desc;</span><br></pre></td></tr></table></figure>
<h5 id="自连接-1"><a href="#自连接-1" class="headerlink" title="自连接"></a>自连接</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#自连接</span><br><span class="line">#查询员工的名字、上级的名字</span><br><span class="line">select e.last_name, m.last_name</span><br><span class="line">from employees e</span><br><span class="line">join employees m</span><br><span class="line">on e.manager_id &#x3D; m.employee_id;</span><br></pre></td></tr></table></figure>
<h4 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">应用场景：用于查询一个表中有，另一个表中没有的记录</span><br><span class="line"></span><br><span class="line">特点：</span><br><span class="line">	1、外连接的查询结果为主表中的所有记录</span><br><span class="line">		如果从表中有和它匹配的，则显示匹配的值</span><br><span class="line">		如果从表中没有和它匹配的，则显示null</span><br><span class="line">		外连接查询结果 &#x3D; 内连接结果 + 主表中有而从表中没有的记录</span><br><span class="line">	2、左外连接，left join左边的是主表</span><br><span class="line">	   右外连接，right join右边的是主表</span><br><span class="line">	3、左外和右外交换两个表的顺序，可以实现同样的效果</span><br><span class="line">	4、全外连接 &#x3D; 内连接的结果 + 表1中有但表2中没有的 + 表2中有但表1中没有的</span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#引入：查询男朋友不在男神表的女神名</span><br><span class="line">select * from beauty;</span><br><span class="line">select * from boys;</span><br><span class="line">#左外</span><br><span class="line">select b.name, bo.*</span><br><span class="line">from beauty b</span><br><span class="line">left outer join boys bo</span><br><span class="line">on b.boyfriend_id &#x3D; bo.id</span><br><span class="line">where bo.id is null;</span><br><span class="line">#右外，与上结果同</span><br><span class="line">select b.name, bo.*</span><br><span class="line">from boys bo</span><br><span class="line">right outer join beauty b</span><br><span class="line">on b.boyfriend_id &#x3D; bo.id</span><br><span class="line">where bo.id is null;</span><br><span class="line">#交叉连接(笛卡尔乘积)</span><br><span class="line">select b.*, bo.*</span><br><span class="line">from beauty b</span><br><span class="line">cross join boys bo;</span><br></pre></td></tr></table></figure>


<h3 id="3、子查询"><a href="#3、子查询" class="headerlink" title="3、子查询"></a><strong>3、子查询</strong></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">含义：</span><br><span class="line">	一条查询语句中又嵌套了另一条完整的select语句，其中被嵌套的select语句，称为子查询或内查询，在外面的查询语句，称为主查询或外查询</span><br><span class="line"></span><br><span class="line">分类：</span><br><span class="line">按子查询出现的位置：</span><br><span class="line">	select后面：</span><br><span class="line">		仅支持标量子查询</span><br><span class="line">	from后面：</span><br><span class="line">		支持表子查询</span><br><span class="line">	where或having后面：</span><br><span class="line">		标量子查询（单行）</span><br><span class="line">		列子查询（多行）</span><br><span class="line">		行子查询</span><br><span class="line">	exists后面（相关子查询）</span><br><span class="line">		表子查询</span><br><span class="line">按结果集的行列数不同：</span><br><span class="line">	标量子查询（结果集只有一行一列）</span><br><span class="line">	列子查询（结果集只有一列多行）</span><br><span class="line">	表子查询（结果集一般为多行多列）</span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure>
<h4 id="where或having后面"><a href="#where或having后面" class="headerlink" title="where或having后面"></a>where或having后面</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">一、where或having后面</span><br><span class="line">	1、标量子查询（单行子查询）</span><br><span class="line">	2、列子查询（多行子查询）</span><br><span class="line">	3、行子查询（多行多列）</span><br><span class="line">	</span><br><span class="line">特点：</span><br><span class="line">    1、子查询都放在小括号内</span><br><span class="line">    2、子查询可以放在from后面、select后面、where后面、having后面，但一般放在条件的右侧</span><br><span class="line">    3、子查询优先于主查询执行，主查询使用了子查询的执行结果</span><br><span class="line">    4、子查询根据查询结果的行数不同分为以下两类：</span><br><span class="line">        ①单行子查询</span><br><span class="line">            结果集只有一行</span><br><span class="line">            一般搭配单行操作符使用：&gt; &lt; &#x3D; &lt;&gt; &gt;&#x3D; &lt;&#x3D; </span><br><span class="line">            非法使用子查询的情况：</span><br><span class="line">            	a、子查询的结果为一组值</span><br><span class="line">            	b、子查询的结果为空</span><br><span class="line">        ② 多行子查询</span><br><span class="line">            结果集有多行</span><br><span class="line">            一般搭配多行操作符使用：any、all、in、not in</span><br><span class="line">            in： 属于子查询结果中的任意一个就行</span><br><span class="line">            any和all往往可以用其他查询代替 </span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#1、标量子查询（单行子查询）------------------------------------------------</span><br><span class="line">#①查询Abel的工资</span><br><span class="line">select salary</span><br><span class="line">from employees</span><br><span class="line">where last_name &#x3D; &#39;Abel&#39;;</span><br><span class="line">#查询员工的信息，满足 salary&gt;①结果</span><br><span class="line">select *</span><br><span class="line">from employees</span><br><span class="line">where salary &gt; (</span><br><span class="line">	select salary</span><br><span class="line">	from employees</span><br><span class="line">	where last_name &#x3D; &#39;Abel&#39;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">#②返回job_id与141号员工相同，salary比143号员工多的员工姓名，job_id和工资</span><br><span class="line">#第一步：①查询141号员工的job_id</span><br><span class="line">select job_id</span><br><span class="line">from employees</span><br><span class="line">where employee_id &#x3D; 141;</span><br><span class="line">#第二步：②查询143号员工的salary</span><br><span class="line">select salary</span><br><span class="line">from employees</span><br><span class="line">where employee_id &#x3D; 143;</span><br><span class="line">#第三步：查询员工的姓名，job_id和工资，要求job_id&#x3D;①并且salary&gt;②</span><br><span class="line">select last_name, job_id, salary</span><br><span class="line">from employees</span><br><span class="line">where job_id&#x3D;(</span><br><span class="line">	select job_id</span><br><span class="line">	from employees</span><br><span class="line">	where employee_id &#x3D; 141</span><br><span class="line">) and salary &gt; (</span><br><span class="line">	select salary</span><br><span class="line">	from employees</span><br><span class="line">	where employee_id &#x3D; 143</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">#查询最低工资大于50号部门最低工资的部门id和其最低工资</span><br><span class="line">select min(salary), department_id</span><br><span class="line">from employees</span><br><span class="line">group by department_id</span><br><span class="line">having min(salary) &gt; (</span><br><span class="line">	select min(salary)</span><br><span class="line">    from employees</span><br><span class="line">    where department_id &#x3D; 50</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#2、列子查询（多行子查询）------------------------------------------------</span><br><span class="line">#返回location_id是1400或1700的部门中的所有员工姓名</span><br><span class="line">select last_name</span><br><span class="line">from employees</span><br><span class="line">where department_id in(</span><br><span class="line">	select distinct department_id</span><br><span class="line">    from departments</span><br><span class="line">    where location_id in(1400, 1700)</span><br><span class="line">);</span><br><span class="line">#或</span><br><span class="line">select last_name</span><br><span class="line">from employees</span><br><span class="line">where department_id &#x3D;any(</span><br><span class="line">	select distinct department_id</span><br><span class="line">    from departments</span><br><span class="line">    where location_id in(1400, 1700)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">#返回location_id不是1400或1700的部门中的所有员工姓名</span><br><span class="line">select last_name</span><br><span class="line">from employees</span><br><span class="line">where department_id not in(</span><br><span class="line">	select distinct department_id</span><br><span class="line">    from departments</span><br><span class="line">    where location_id in(1400, 1700)</span><br><span class="line">);</span><br><span class="line">#或</span><br><span class="line">select last_name</span><br><span class="line">from employees</span><br><span class="line">where department_id &lt;&gt;all(</span><br><span class="line">	select distinct department_id</span><br><span class="line">    from departments</span><br><span class="line">    where location_id in(1400, 1700)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#返回其他部门（意思是除去部门IT_PROG的）中比job_id为&#39;IT_PROG&#39;工种任一工资低的员工的员工号、姓名、job_id以及salary</span><br><span class="line">#一、先查询job_id为&#39;IT_PROG&#39;工种任一工资</span><br><span class="line">select distinct salary</span><br><span class="line">from employees</span><br><span class="line">where job_id &#x3D; &#39;IT_PROG&#39;;</span><br><span class="line">#二、查询员工号、姓名、job_id以及salary，salary &lt; (一)的任意一个</span><br><span class="line">select last_name, employee_id, job_id, salary</span><br><span class="line">from employees</span><br><span class="line">where salary &lt; any(</span><br><span class="line">	select distinct salary</span><br><span class="line">	from employees</span><br><span class="line">	where job_id &#x3D; &#39;IT_PROG&#39;</span><br><span class="line">) and job_id &lt;&gt; &#39;IT_PROG&#39;;</span><br><span class="line">#或</span><br><span class="line">select last_name, employee_id, job_id, salary</span><br><span class="line">from employees</span><br><span class="line">where salary &lt; (</span><br><span class="line">	select  max(salary)</span><br><span class="line">	from employees</span><br><span class="line">	where job_id &#x3D; &#39;IT_PROG&#39;</span><br><span class="line">) and job_id &lt;&gt; &#39;IT_PROG&#39;;</span><br><span class="line"></span><br><span class="line">#返回其他部门（意思是除去部门IT_PROG的）中比job_id为&#39;IT_PROG&#39;工种所有工资低的员工的员工号、姓名、job_id以及salary</span><br><span class="line">select last_name, employee_id, job_id, salary</span><br><span class="line">from employees</span><br><span class="line">where salary &lt; all(</span><br><span class="line">	select distinct salary</span><br><span class="line">	from employees</span><br><span class="line">	where job_id &#x3D; &#39;IT_PROG&#39;</span><br><span class="line">) and job_id &lt;&gt; &#39;IT_PROG&#39;;</span><br><span class="line">#或</span><br><span class="line">select last_name, employee_id, job_id, salary</span><br><span class="line">from employees</span><br><span class="line">where salary &lt; (</span><br><span class="line">	select  min(salary)</span><br><span class="line">	from employees</span><br><span class="line">	where job_id &#x3D; &#39;IT_PROG&#39;</span><br><span class="line">) and job_id &lt;&gt; &#39;IT_PROG&#39;;</span><br><span class="line"></span><br><span class="line">#3、行子查询（多行多列）------------------------------------------------</span><br><span class="line">#查询员工编号最小并且工资最高的员工信息</span><br><span class="line">select *</span><br><span class="line">from employees</span><br><span class="line">where (employee_id, salary) &#x3D; (</span><br><span class="line">	select min(employee_id), max(salary)</span><br><span class="line">    from employees</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h4 id="select后面"><a href="#select后面" class="headerlink" title="select后面"></a>select后面</h4><h4 id="from后面"><a href="#from后面" class="headerlink" title="from后面"></a>from后面</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#查询每个部门的平均工资的工资等级</span><br><span class="line">#(将子查询结果充当一张表，要求必须其别名)</span><br><span class="line">select ag_dep.*, g.grade_level</span><br><span class="line">from (</span><br><span class="line">	select avg(salary) ag, department_id</span><br><span class="line">	from employees</span><br><span class="line">	group by department_id</span><br><span class="line">) ag_dep</span><br><span class="line">inner join job_grades g</span><br><span class="line">on ag_dep.ag between lowest_sal and highest_sal;</span><br></pre></td></tr></table></figure>
<h4 id="exists后面"><a href="#exists后面" class="headerlink" title="exists后面"></a>exists后面</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#结果为0或1，判断是否存在</span><br><span class="line">select exists(</span><br><span class="line">	select employee_id</span><br><span class="line">    from employees</span><br><span class="line">    where salary&#x3D;300000</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">#查询有员工的部门名</span><br><span class="line">select department_name</span><br><span class="line">from departments d</span><br><span class="line">where exists(</span><br><span class="line">	select *</span><br><span class="line">    from employees e</span><br><span class="line">    where d.department_id &#x3D; e.department_id</span><br><span class="line">);</span><br><span class="line">#或</span><br><span class="line">select department_name</span><br><span class="line">from departments d</span><br><span class="line">where d.department_id in(</span><br><span class="line">	select department_id</span><br><span class="line">    from employees</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">#查询没有女朋友的男神信息</span><br><span class="line">use girls;</span><br><span class="line">select bo.*</span><br><span class="line">from boys bo</span><br><span class="line">where bo.&#96;id&#96; not in(</span><br><span class="line">	select boyfriend_id</span><br><span class="line">    from beauty</span><br><span class="line">);</span><br><span class="line">#或</span><br><span class="line">select bo.*</span><br><span class="line">from boys bo</span><br><span class="line">where not exists(</span><br><span class="line">	select boyfriend_id</span><br><span class="line">    from beauty b</span><br><span class="line">    where bo.&#96;id&#96;&#x3D;b.&#96;boyfriend_id&#96;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h3 id="4、分页查询"><a href="#4、分页查询" class="headerlink" title="4、分页查询"></a><strong>4、分页查询</strong></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*语法：</span><br><span class="line">select 字段|表达式,...</span><br><span class="line">from 表</span><br><span class="line">【where 条件】</span><br><span class="line">【group by 分组字段】</span><br><span class="line">【having 条件】</span><br><span class="line">【order by 排序的字段】</span><br><span class="line">limit 【offset起始的条目索引，】 size条目数;</span><br><span class="line"></span><br><span class="line">特点：</span><br><span class="line">	1.起始条目索引从0开始</span><br><span class="line">	2.limit子句放在查询语句的最后</span><br><span class="line">	3.公式：select * from  表 limit （page-1）*sizePerPage,sizePerPage</span><br><span class="line">            假如:</span><br><span class="line">            每页显示条目数sizePerPage</span><br><span class="line">            要显示的页数 page</span><br><span class="line">*&#x2F;</span><br><span class="line">#查询前五条员工信息</span><br><span class="line">select * from employees limit 0, 5;</span><br><span class="line"></span><br><span class="line">#查询第11条到第25条</span><br><span class="line">select * from employees limit 10, 15;</span><br><span class="line"></span><br><span class="line">#有奖金的员工信息，并且工资较高的前10名显示出来</span><br><span class="line">select *</span><br><span class="line">from employees</span><br><span class="line">where commission_pct is not null</span><br><span class="line">order by salary desc</span><br><span class="line">limit 10;</span><br></pre></td></tr></table></figure>
<h3 id="5、联合查询"><a href="#5、联合查询" class="headerlink" title="5、联合查询"></a><strong>5、联合查询</strong></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">语法：</span><br><span class="line">select 字段|常量|表达式|函数 【from 表】 【where 条件】 union 【all】</span><br><span class="line">select 字段|常量|表达式|函数 【from 表】 【where 条件】 union 【all】</span><br><span class="line">select 字段|常量|表达式|函数 【from 表】 【where 条件】 union  【all】</span><br><span class="line">.....</span><br><span class="line">select 字段|常量|表达式|函数 【from 表】 【where 条件】</span><br><span class="line"></span><br><span class="line">特点：</span><br><span class="line">	1、多条查询语句的查询的列数必须是一致的</span><br><span class="line">	2、多条查询语句的查询的列的类型和顺序要一致</span><br><span class="line">	3、union代表去重，union all代表不去重</span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">#查询部门编号&gt;90或者邮箱包含a的员工信息</span><br><span class="line">select *</span><br><span class="line">from employees where email like &#39;%a%&#39; or department_id &gt; 90;</span><br><span class="line">#等同于</span><br><span class="line">select * from employees where email like &#39;%a%&#39;</span><br><span class="line">union</span><br><span class="line">select * from employees where department_id &gt; 90;</span><br><span class="line"></span><br><span class="line">#查询中国用户中男性的信息以及外国用户中年男性的用户信息</span><br><span class="line">select id, cname, csex from t_ca where csex&#x3D;&#39;男&#39;</span><br><span class="line">union</span><br><span class="line">select t_id, tName, tGender from t_ua where tGender &#x3D; &#39;male&#39;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql学习笔记Day5</title>
    <url>/2021/03/18/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0Day5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>[TOC]</p>
<h1 id="Day"><a href="#Day" class="headerlink" title="Day"></a>Day</h1><h3 id="1、函数"><a href="#1、函数" class="headerlink" title="1、函数"></a><strong>1、函数</strong></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">含义：一组预先编译好的SQL语句的集合，可理解成批处理语句</span><br><span class="line">	1、提高代码的重用性</span><br><span class="line">	2、简化操作</span><br><span class="line">	3、减少了编译次数并且减少了和数据库服务器的连接次数，提高了效率</span><br><span class="line">	</span><br><span class="line">区别：</span><br><span class="line">	存储过程：可以有0个返回，也可以有多个返回，适合做批量插入、批量更新</span><br><span class="line">	函数：有且仅有一个返回，适合做处理数据后返回一个结果</span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line">一、创建语法</span><br><span class="line">create function 函数名（参数列表） return 返回类型</span><br><span class="line">begin</span><br><span class="line">	函数体</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">	1、参数列表包含两部分：</span><br><span class="line">		参数名、参数类型</span><br><span class="line">	2、函数体：肯定会有return语句，如果没有会报错，如果return语句没有放在函数体的最后不会报错，但不建议return 值</span><br><span class="line">	3、函数体中仅有一句话，则可以省略begin end</span><br><span class="line">	4、使用 delimiter 语句设置结束标记</span><br><span class="line"></span><br><span class="line">二、调用语法</span><br><span class="line">select 函数名（参数列表）</span><br><span class="line"></span><br><span class="line">三、查看函数</span><br><span class="line">show create function 函数名;</span><br><span class="line"></span><br><span class="line">四、删除函数</span><br><span class="line">drop function 函数名;</span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">#返回公司的员工个数（无参返回）</span><br><span class="line">create function myf1() returns int</span><br><span class="line">begin</span><br><span class="line">	declare c int default 0	#定义变量</span><br><span class="line">	select count(*) into c	#赋值</span><br><span class="line">	from employees;</span><br><span class="line">	return c;</span><br><span class="line">end $</span><br><span class="line"></span><br><span class="line">#根据员工名返回他的工资（有参返回）</span><br><span class="line">create function myf2(cmpName varchar(20)) return double</span><br><span class="line">begin</span><br><span class="line">	set @sal&#x3D;0;</span><br><span class="line">	select salary into @sal</span><br><span class="line">	from employees</span><br><span class="line">	where last_name &#x3D; empName;</span><br><span class="line">	return @sal;</span><br><span class="line">end $</span><br></pre></td></tr></table></figure>
<h3 id="2、流程控制图"><a href="#2、流程控制图" class="headerlink" title="2、流程控制图"></a><strong>2、流程控制图</strong></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">顺序结构：程序从上往下依次执行</span><br><span class="line">分支结构：程序从两条或多条路径中选择一条去执行</span><br><span class="line">循环结构：程序在满足一定条件的基础上，重复执行一段代码</span><br><span class="line">*&#x2F;</span><br><span class="line">一、分支结构</span><br><span class="line">1、 if 函数</span><br><span class="line">	语法：if(条件，值1，值2)</span><br><span class="line">	特点：可以用在任何位置</span><br><span class="line">2、 case 结构</span><br><span class="line">	情况一：类似于switch</span><br><span class="line">    case 表达式</span><br><span class="line">    when 值1 then 结果1或语句1(如果是语句，需要加分号) </span><br><span class="line">    when 值2 then 结果2或语句2(如果是语句，需要加分号)</span><br><span class="line">    ...</span><br><span class="line">    else 结果n或语句n(如果是语句，需要加分号)</span><br><span class="line">    end 【case】（如果是放在begin end中需要加上case，如果放在select后面不需要）</span><br><span class="line"></span><br><span class="line">    情况二：类似于多重if</span><br><span class="line">    case </span><br><span class="line">    when 条件1 then 结果1或语句1(如果是语句，需要加分号) </span><br><span class="line">    when 条件2 then 结果2或语句2(如果是语句，需要加分号)</span><br><span class="line">    ...</span><br><span class="line">    else 结果n或语句n(如果是语句，需要加分号)</span><br><span class="line">    end 【case】（如果是放在begin end中需要加上case，如果放在select后面不需要）</span><br><span class="line">3、 if 结构</span><br><span class="line">    if 情况1 then 语句1;</span><br><span class="line">    elseif 情况2 then 语句2;</span><br><span class="line">    ...</span><br><span class="line">    else 语句n;</span><br><span class="line">    end if;</span><br><span class="line">    </span><br><span class="line">二、循环结构</span><br><span class="line">语法：</span><br><span class="line">	【标签：】WHILE 循环条件  DO</span><br><span class="line">        循环体</span><br><span class="line">    END WHILE 【标签】;</span><br><span class="line">    </span><br><span class="line">特点：</span><br><span class="line">    只能放在BEGIN END里面</span><br><span class="line">    如果要搭配leave跳转语句，需要使用标签，否则可以不用标签</span><br><span class="line">    leave类似于java中的break语句，跳出所在循环！！！</span><br></pre></td></tr></table></figure>
<img src= "/img/loading.gif" data-lazy-src="C:%5CUsers%5CHasee%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210112202633843.png" alt="image-20210112202633843" style="zoom:80%;" />]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构_二叉树的应用_练习题</title>
    <url>/2020/03/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%94%E7%94%A8-%E7%BB%83%E4%B9%A0%E9%A2%98/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>树与二叉树的应用包括二叉排序树、平衡二叉树、哈夫曼树等等</p>
<h5 id="二叉排序树的一些基本操作"><a href="#二叉排序树的一些基本操作" class="headerlink" title="二叉排序树的一些基本操作"></a>二叉排序树的一些基本操作</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//二叉排序树的非递归查找</span></span><br><span class="line"><span class="function">BiTree <span class="title">BSTSearch</span><span class="params">(BiTree T, ElemType key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (T != <span class="literal">nullptr</span> &amp;&amp; T-&gt;data != key) &#123;</span><br><span class="line">        <span class="keyword">if</span> (key &lt; T-&gt;data)</span><br><span class="line">            T = T-&gt;lchild;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            T = T-&gt;rchild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二叉排序树的递归查找</span></span><br><span class="line"><span class="function">BiTree <span class="title">BSTSearch2</span><span class="params">(BiTree T, ElemType key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (key == T-&gt;data)</span><br><span class="line">        <span class="keyword">return</span> T;</span><br><span class="line">    <span class="keyword">if</span> (key &lt; T-&gt;data)</span><br><span class="line">        <span class="keyword">return</span> BSTSearch2(T-&gt;lchild, key);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> BSTSearch2(T-&gt;rchild, key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二叉排序树的插入</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BSTInsert</span><span class="params">(BiTree &amp;T, ElemType key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//当查找失败时，会开始插入key结点</span></span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        T = (BiTree) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTree));</span><br><span class="line">        T-&gt;data = key;</span><br><span class="line">        T-&gt;lchild = T-&gt;rchild = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key == T-&gt;data) &#123;</span><br><span class="line">        <span class="comment">//若已经存在，则插入失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &lt; T-&gt;data)</span><br><span class="line">        <span class="keyword">return</span> BSTInsert(T-&gt;lchild, key);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> BSTInsert(T-&gt;rchild, key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二叉排序树的构造</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BSTCreate</span><span class="params">(BiTree &amp;T, ElemType key[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//初始时二叉排序树为空</span></span><br><span class="line">    T = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">        BSTInsert(T, key[i]);</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="二叉树树的应用"><a href="#二叉树树的应用" class="headerlink" title="二叉树树的应用"></a>二叉树树的应用</h5><p>判断一个给定的二叉树是否是二叉排序树，算法思想，因为二叉排序树的中序遍历是从小到大的，因此只需判断其中序遍历是否从小到大有序即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> MIN = <span class="number">-32767</span>;    <span class="comment">//首先设定一个用于比较的最小值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">JudegBST</span><span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> b1, b2;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;   <span class="comment">//空树</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        b1 = JudegBST(T-&gt;lchild);</span><br><span class="line">        <span class="keyword">if</span> (b1 == <span class="number">0</span> || MIN &gt;= T-&gt;data)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        MIN = T-&gt;data;</span><br><span class="line">        b2 = JudegBST(T-&gt;rchild);</span><br><span class="line">        <span class="keyword">return</span> b2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>求出指定结点在二叉排序树中的层次，算法思想：查找一次就下降一层</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SarchLevel</span><span class="params">(BiTree T, BiTree key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    BiTree p = T;</span><br><span class="line">    <span class="keyword">if</span> (T) &#123;</span><br><span class="line">        n++;</span><br><span class="line">        <span class="keyword">while</span> (p-&gt;data != key-&gt;data) &#123;</span><br><span class="line">            <span class="keyword">if</span> (key-&gt;data &lt; p-&gt;data)</span><br><span class="line">                p = p-&gt;lchild;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p = p-&gt;rchild;</span><br><span class="line">            n++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用二叉树遍历的思想判断一个二叉树是否是平衡二叉树，算法思想：高度为0或1，则为平衡二叉树，否则左右子树的高度差不能大于1，balance判断是否是平衡二叉树，h表示高度，int &amp;balance, int &amp;h加引用(&amp;)的原因是会被修改</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">JudgeAVL</span><span class="params">(BiTree T, <span class="keyword">int</span> &amp;balance, <span class="keyword">int</span> &amp;h)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//左右子树的平衡标记和高度</span></span><br><span class="line">    <span class="keyword">int</span> bl, br, hl, hr;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">nullptr</span>) &#123; <span class="comment">//树空</span></span><br><span class="line">        balance = <span class="number">1</span>;</span><br><span class="line">        h = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (T-&gt;lchild == <span class="literal">nullptr</span> &amp;&amp; T-&gt;rchild == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">//仅有根结点</span></span><br><span class="line">        h = <span class="number">1</span>;</span><br><span class="line">        balance = <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        JudgeAVL(T-&gt;rchild, bl, hl);</span><br><span class="line">        JudgeAVL(T-&gt;rchild, br, hr);</span><br><span class="line">        <span class="comment">//这里加1加的是根结点，因为前面已经处理了根结点</span></span><br><span class="line">        h = (hl &gt; hr ? hl : hr) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">abs</span>(hl - hr) &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="comment">//左右子树都平衡才整体平衡</span></span><br><span class="line">            balance = bl &amp; br;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            balance = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>求出给定二叉排序序树中的最大值和最小值的关键字，算法思想：对于二叉排序树，最小值在左下角，最大值在右下角</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ElemType <span class="title">MaxKey</span><span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (T-&gt;rchild != <span class="literal">nullptr</span>)</span><br><span class="line">        T = T-&gt;rchild;</span><br><span class="line">    <span class="keyword">return</span> T-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ElemType <span class="title">MinKey</span><span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (T-&gt;lchild != <span class="literal">nullptr</span>)</span><br><span class="line">        T = T-&gt;lchild;</span><br><span class="line">    <span class="keyword">return</span> T-&gt;data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从大到小输出二叉排序树中所有不小于k的值，算法思想：因为是从大到小输出，所以先遍历右子树，再遍历左子树，用递归的方法可以从最大开始，直到最小</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OutPutKey</span><span class="params">(BiTree T, ElemType k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (T-&gt;rchild != <span class="literal">nullptr</span>)</span><br><span class="line">        OutPutKey(T-&gt;rchild, k);</span><br><span class="line">    <span class="keyword">if</span> (T-&gt;data == k)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; T-&gt;data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">if</span> (T-&gt;lchild != <span class="literal">nullptr</span>)</span><br><span class="line">        OutPutKey(T-&gt;lchild, k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>C++</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构_二叉树的遍历/线索二叉树</title>
    <url>/2020/03/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86-%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>​    原始头文件和一些其中会用到的函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by XuYiMing on 2020/3/2.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二叉树的链式存储</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> &#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125; BiTNode, *BiTree;</span><br><span class="line"></span><br><span class="line"><span class="function">ElemType <span class="title">visit</span><span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> T-&gt;data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><h4 id="二叉树遍历方法"><a href="#二叉树遍历方法" class="headerlink" title="二叉树遍历方法"></a>二叉树遍历方法</h4></li>
</ul>
<ol>
<li><h6 id="用递归方法解决遍历问题"><a href="#用递归方法解决遍历问题" class="headerlink" title="用递归方法解决遍历问题"></a>用递归方法解决遍历问题</h6><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//先序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrder</span><span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        visit(T);</span><br><span class="line">        PreOrder(T-&gt;lchild);</span><br><span class="line">        PreOrder(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrder</span><span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        InOrder(T-&gt;lchild);</span><br><span class="line">        visit(T);</span><br><span class="line">        InOrder(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrder</span><span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        PostOrder(T-&gt;lchild);</span><br><span class="line">        PostOrder(T-&gt;rchild);</span><br><span class="line">        visit(T);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//层次遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LevelOrder</span><span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;BiTree&gt; q;</span><br><span class="line">    BiTree p = T;</span><br><span class="line">    q.push(T);</span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        q.pop();</span><br><span class="line">        visit(p);</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;lchild != <span class="literal">nullptr</span>)</span><br><span class="line">            q.push(p-&gt;lchild);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;rchild != <span class="literal">nullptr</span>)</span><br><span class="line">            q.push(p-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
<li><h6 id="用非递归方法解决遍历问题"><a href="#用非递归方法解决遍历问题" class="headerlink" title="用非递归方法解决遍历问题"></a>用非递归方法解决遍历问题</h6></li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//先序遍历非递归算法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrder2</span><span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    BiTree p = T;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">nullptr</span> || !s.empty()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p) &#123;</span><br><span class="line">            visit(p);</span><br><span class="line">            s.push(p-&gt;data);</span><br><span class="line">            p = p-&gt;lchild;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            s.pop();</span><br><span class="line">            p = p-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序遍历非递归算法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrder2</span><span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    BiTree p = T;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">nullptr</span> || !s.empty()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p) &#123;</span><br><span class="line">            s.push(p-&gt;data);</span><br><span class="line">            p = p-&gt;lchild;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            s.pop();</span><br><span class="line">            visit(p);</span><br><span class="line">            p = p-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后序遍历非递归算法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrder2</span><span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;BiTree&gt; s;</span><br><span class="line">    BiTree p = T;</span><br><span class="line">    <span class="comment">//r为辅助指针，用于指向最近访问过的结点</span></span><br><span class="line">    BiTree r = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span> (p || !s.empty()) &#123;</span><br><span class="line">        <span class="comment">//走到最左边，找到后序遍历的第一个结点</span></span><br><span class="line">        <span class="keyword">if</span> (p) &#123;</span><br><span class="line">            s.push(p);</span><br><span class="line">            p = p-&gt;lchild;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//读取栈顶结点</span></span><br><span class="line">            p = s.top();</span><br><span class="line">            <span class="comment">//右子节点存在且未被访问过</span></span><br><span class="line">            <span class="keyword">if</span> (p-&gt;rchild &amp;&amp; p-&gt;rchild != r) &#123;</span><br><span class="line">                p = p-&gt;rchild;</span><br><span class="line">                s.push(p);</span><br><span class="line">                p = p-&gt;lchild;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//否则从栈中弹出还未被访问的结点</span></span><br><span class="line">                s.pop();</span><br><span class="line">                visit(p);</span><br><span class="line">                <span class="comment">//把r指向该节点已被访问</span></span><br><span class="line">                r = p;</span><br><span class="line">                <span class="comment">//每次出栈访问完一个结点都是该结点的子树，需将p置null</span></span><br><span class="line">                p = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><h4 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//线索二叉树的存储结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span> &#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">    <span class="keyword">int</span> ltag, rtag;</span><br><span class="line">    <span class="comment">//tag为0表示孩子，为1表示前驱/后继</span></span><br><span class="line">&#125; ThreadNode, *ThreadTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序线索二叉树的递归算法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InThread</span><span class="params">(ThreadTree &amp;p, ThreadTree &amp;pre)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">//递归线索化左子树</span></span><br><span class="line">        InThread(p-&gt;lchild, pre);</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;lchild == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            p-&gt;lchild = pre;</span><br><span class="line">            p-&gt;ltag = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//建立前驱结点的后继线索</span></span><br><span class="line">        <span class="keyword">if</span> (pre != <span class="literal">nullptr</span> &amp;&amp; pre-&gt;rchild == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            pre-&gt;rchild = p;</span><br><span class="line">            pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = p;</span><br><span class="line">        InThread(pre-&gt;rchild, pre);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//建立中序线索二叉树的过程</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateInThread</span><span class="params">(ThreadTree T)</span> </span>&#123;</span><br><span class="line">    ThreadTree pre = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (T != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">//线索化二叉树</span></span><br><span class="line">        InThread(T, pre);</span><br><span class="line">        <span class="comment">//处理遍历后的最后一个结点</span></span><br><span class="line">        pre-&gt;rchild = <span class="literal">nullptr</span>;</span><br><span class="line">        pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>C++</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构_二叉树遍历_线索二叉树_练习题</title>
    <url>/2020/03/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86-%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91-%E7%BB%83%E4%B9%A0%E9%A2%98/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ol>
<li><p>给出二叉树自下而上，自右到左的层次遍历算法，算法思想：在一般的层次遍历的同时出队，并将结点放入栈中，最后从栈顶开始出栈即是逆序的层次遍历</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ReverseLevel</span><span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;BiTree&gt; s;</span><br><span class="line">    <span class="built_in">queue</span>&lt;BiTree&gt; q;</span><br><span class="line">    BiTree p;</span><br><span class="line">    <span class="keyword">if</span> (T) &#123;</span><br><span class="line">        q.push(T);      <span class="comment">//将根结点入队</span></span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;    <span class="comment">//当队列不为空时</span></span><br><span class="line">            p = q.front();      <span class="comment">//结点出队</span></span><br><span class="line">            q.pop();            <span class="comment">//从删除该结点</span></span><br><span class="line">            s.push(p);          <span class="comment">//把结点放入栈</span></span><br><span class="line">            <span class="keyword">if</span> (p-&gt;lchild != <span class="literal">nullptr</span>)</span><br><span class="line">                q.push(p);</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;rchild != <span class="literal">nullptr</span>)</span><br><span class="line">                q.push(p);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!s.empty()) &#123;</span><br><span class="line">            p = s.top();</span><br><span class="line">            s.pop();</span><br><span class="line">            visit(p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>假设二叉树采用二叉链表存储结构，设计非递归算法求二叉树的高度，算法思想：采用层次遍历，用level记录层数，设置变量last指向当前层最右结点，当遍历到last时，层数加1</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BiTdepth1</span><span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!T)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;   <span class="comment">//树空返回0</span></span><br><span class="line">    <span class="keyword">int</span> front = <span class="number">-1</span>, rear = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//用于指向当前层的最后一个节点，level记录层数</span></span><br><span class="line">    <span class="keyword">int</span> last = <span class="number">0</span>, level = <span class="number">0</span>;</span><br><span class="line">    BiTree Q[MaxSize];  <span class="comment">//建立二叉树结点指针类型的队列</span></span><br><span class="line">    Q[++rear] = T;  <span class="comment">//将根结点入队</span></span><br><span class="line">    BiTree p;</span><br><span class="line">    <span class="keyword">while</span> (front &lt; rear) &#123;  <span class="comment">//队不空</span></span><br><span class="line">        p = Q[++front];     <span class="comment">//取出正在访问的结点</span></span><br><span class="line">        <span class="keyword">if</span> (p-&gt;lchild)</span><br><span class="line">            Q[++rear] = p-&gt;lchild;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;rchild)</span><br><span class="line">            Q[++rear] = p-&gt;rchild;</span><br><span class="line">        <span class="keyword">if</span> (front == last) &#123;    <span class="comment">//到一层的最后一个结点时</span></span><br><span class="line">            level++;        <span class="comment">//层数加一</span></span><br><span class="line">            last = rear;    <span class="comment">//把last下一层的最后一个结点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> level;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归法解决此题</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BiTdepth2</span><span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!T)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ldep = BiTdepth2(T-&gt;lchild);</span><br><span class="line">    <span class="keyword">int</span> rdep = BiTdepth2(T-&gt;rchild);</span><br><span class="line">    <span class="keyword">if</span> (ldep &gt; rdep)</span><br><span class="line">        <span class="keyword">return</span> ldep + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> rdep + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>设一棵二叉树中各结点的值互不相同，其先序遍历和后序遍历序列分别存放于A和B数组，编写算法建立二叉链表</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">BiTree <span class="title">AB_Create</span><span class="params">(ElemType A[], ElemType B[], <span class="keyword">int</span> l1, <span class="keyword">int</span> h1, <span class="keyword">int</span> l2, <span class="keyword">int</span> h2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//l1, h1, l2, h2分别为先序和中序的第一个和最后一个结点</span></span><br><span class="line">    <span class="comment">//假设初始调用时：l1=l2=1, h1=h2=n</span></span><br><span class="line">    BiTree root = (BiTree) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTree));      <span class="comment">//建立根结点</span></span><br><span class="line">    root-&gt;data = A[l1];    <span class="comment">//根结点</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = l2; B[i] != root-&gt;data; i++);          <span class="comment">//在中序序列中找到根结点的划分</span></span><br><span class="line">    <span class="keyword">int</span> Llen = i - l2;      <span class="comment">//左子树长度</span></span><br><span class="line">    <span class="keyword">int</span> Rlen = h2 - i;      <span class="comment">//右子树长度</span></span><br><span class="line">    <span class="keyword">if</span> (Llen)       <span class="comment">//递归建立左子树</span></span><br><span class="line">        root-&gt;lchild = AB_Create(A, B, l1 + <span class="number">1</span>, l1 + Llen, l2, l2 + Llen - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        root-&gt;lchild = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (Rlen)       <span class="comment">//递归建立右子树</span></span><br><span class="line">        root-&gt;rchild = AB_Create(A, B, h1 - Rlen + <span class="number">1</span>, h1, h2 - Rlen + <span class="number">1</span>, h2);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        root-&gt;rchild = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>二叉树链式存储，判断是否是完全二叉树，算法思想：层次遍历，若出现空节点后还有非空节点，则不是完全二叉树</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsComplete</span><span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;BiTree&gt; q;</span><br><span class="line">    <span class="keyword">if</span> (!T)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;       <span class="comment">//空树为满二叉树</span></span><br><span class="line">    BiTree p;</span><br><span class="line">    q.push(T);</span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        p = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">if</span> (p) &#123;</span><br><span class="line">            q.push(p-&gt;lchild);</span><br><span class="line">            q.push(p-&gt;rchild);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//这一步跳过空节点，若之后还出现非空节点，则不是</span></span><br><span class="line">            <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">                p = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                <span class="keyword">if</span> (p)</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>计算一棵链式二叉树所有双分支结点个数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DsonsNode</span><span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (T-&gt;lchild != <span class="literal">nullptr</span> &amp;&amp; T-&gt;rchild != <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="comment">//若找到了含有两个孩子结点的结点，则+1，并继续往下找</span></span><br><span class="line">        <span class="keyword">return</span> DsonsNode(T-&gt;lchild) + DsonsNode(T-&gt;rchild) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">//否则继续往下找，但是此时不计个数</span></span><br><span class="line">        <span class="keyword">return</span> DsonsNode(T-&gt;lchild) + DsonsNode(T-&gt;rchild);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>把树B中所有结点的左右子树交换的函数，算法思想：首先交换B结点的左孩子的左右子树，然后交换B结点的右孩子的左右子树，最后交换B结点的左右孩子</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BiTswap</span><span class="params">(BiTree B)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (B) &#123;</span><br><span class="line">        <span class="comment">//递归交换左右子树</span></span><br><span class="line">        BiTswap(B-&gt;lchild);</span><br><span class="line">        BiTswap(B-&gt;rchild);</span><br><span class="line">        <span class="comment">//交换左右子树</span></span><br><span class="line">        BiTree T = B-&gt;lchild;</span><br><span class="line">        B-&gt;lchild = B-&gt;rchild;</span><br><span class="line">        B-&gt;rchild = T;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>C++</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构_栈</title>
    <url>/2020/03/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h5 id="数据结构栈的实现！"><a href="#数据结构栈的实现！" class="headerlink" title="数据结构栈的实现！"></a>数据结构栈的实现！</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by XuYiMing on 2020/2/21.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 50</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElementType;</span><br><span class="line"></span><br><span class="line"><span class="comment">//*********************顺序栈*****************</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    ElementType data[MaxSize];</span><br><span class="line">    <span class="keyword">int</span> top;</span><br><span class="line">&#125; SqStack;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitStack</span><span class="params">(SqStack &amp;s)</span> </span>&#123;        <span class="comment">//栈初始化</span></span><br><span class="line">    s.top = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">StackEmpty</span><span class="params">(SqStack &amp;s)</span> </span>&#123;       <span class="comment">//栈判空</span></span><br><span class="line">    <span class="keyword">if</span> (s.top == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">PushStack</span><span class="params">(SqStack &amp;s, ElementType x)</span> </span>&#123;     <span class="comment">//进栈</span></span><br><span class="line">    <span class="keyword">if</span> (s.top + <span class="number">1</span> == MaxSize)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    s.data[++s.top] = x;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">PopStack</span><span class="params">(SqStack &amp;s, ElementType &amp;x)</span> </span>&#123;     <span class="comment">//出栈</span></span><br><span class="line">    <span class="keyword">if</span> (s.top == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    x = s.data[s.top--];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">GetTop</span><span class="params">(SqStack s, ElementType &amp;x)</span> </span>&#123;        <span class="comment">//读栈顶元素</span></span><br><span class="line">    <span class="keyword">if</span> (s.top == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    x = s.data[s.top];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//*****************链栈******************</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span> &#123;</span></span><br><span class="line">    ElementType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; *LiStack;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>C++</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构_链式表</title>
    <url>/2020/02/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E5%BC%8F%E8%A1%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h5 id="数据结构链式表的实现！"><a href="#数据结构链式表的实现！" class="headerlink" title="数据结构链式表的实现！"></a>数据结构链式表的实现！</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by XuYiMing on 2020/2/3.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////单链表//////////////</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> &#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; LNode, *LinkList; <span class="comment">// *LinkList表示人为增加的头结点，也可以用LNode *表示，LinkList是全局变量 指向头结点，可以这样定义：LNode *LinkList</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//头插法建立单链表（输出时会得到反序的链表）</span></span><br><span class="line"><span class="function">LinkList <span class="title">List_HeadInsert</span><span class="params">(LinkList &amp;L)</span> </span>&#123;     <span class="comment">//时间复杂度为O(n)</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    LinkList s;     <span class="comment">//LNode *s;</span></span><br><span class="line">    L = (LinkList) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));   <span class="comment">//L = (LNode *) malloc(sizeof(LNode));  为头结点申请内存分配</span></span><br><span class="line">    L-&gt;next = <span class="literal">nullptr</span>;     <span class="comment">//初始化为空链表</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入结点的值，输入9999表示结束：&quot;</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">    <span class="keyword">while</span> (x != <span class="number">9999</span>) &#123;</span><br><span class="line">        s = (LinkList) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">        s-&gt;data = x;</span><br><span class="line">        s-&gt;next = L-&gt;next;</span><br><span class="line">        L-&gt;next = s;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入结点的值，输入9999表示结束：&quot;</span>;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//尾插法建立单链表（输出时会得到正序的链表）</span></span><br><span class="line"><span class="function">LinkList <span class="title">List_TailInsert</span><span class="params">(LinkList &amp;L)</span> </span>&#123;     <span class="comment">//时间复杂度为O(n)</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    L = (LinkList) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    LinkList s, r = L;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入结点的值，输入9999表示结束：&quot;</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">    <span class="keyword">while</span> (x != <span class="number">9999</span>) &#123;</span><br><span class="line">        s = (LinkList) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">        s-&gt;data = x;</span><br><span class="line">        r-&gt;next = s;</span><br><span class="line">        r = s;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入结点的值，输入9999表示结束：&quot;</span>;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">    &#125;</span><br><span class="line">    r-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//按序号查找结点值（时间复杂度为O(n)）</span></span><br><span class="line"><span class="function">LinkList <span class="title">GetElem</span><span class="params">(LinkList L, <span class="keyword">int</span> i)</span> </span>&#123;       <span class="comment">//因为不会对链表进行改动，所以可以不用 &amp;L，直接用 L</span></span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line">    LinkList p = L-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>)     <span class="comment">//返回头结点</span></span><br><span class="line">        <span class="keyword">return</span> L;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span> (p &amp;&amp; j &lt; i) &#123;    <span class="comment">//从第一个结点出发，逐个往下查找第i个结点</span></span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;   <span class="comment">//返回第i个结点的指针，若i大于表长则返回 NULL</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//按值查找表结点（时间复杂度为O(n)）</span></span><br><span class="line"><span class="function">LinkList <span class="title">LocateElem</span><span class="params">(LinkList L, ElemType e)</span> </span>&#123;</span><br><span class="line">    LinkList p = L-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (p-&gt;data != e &amp;&amp; p != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;       <span class="comment">//找到则返回该结点指针，否则返回 NULL</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在位置i上插入新值e</span></span><br><span class="line"><span class="function">LinkList <span class="title">ListInsert</span><span class="params">(LinkList &amp;L, <span class="keyword">int</span> i, ElemType e)</span> </span>&#123;</span><br><span class="line"><span class="comment">//法一：</span></span><br><span class="line"><span class="comment">// （对位置i前插操作，时间复杂度为O（n），对位置i的前驱结点后插操作，时间复杂度O（1））</span></span><br><span class="line"><span class="comment">//主要消耗时间在查找上</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    LinkList p = GetElem(L, i - <span class="number">1</span>);    <span class="comment">//找到要插入的位置的前驱结点</span></span><br><span class="line">    LinkList s;</span><br><span class="line">    s = (LinkList) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));   <span class="comment">//新建一个结点放要插入的值</span></span><br><span class="line">    s-&gt;data = e;</span><br><span class="line">    s-&gt;next = p-&gt;next;  <span class="comment">//对位置i的前驱结点后插操作</span></span><br><span class="line">    p-&gt;next = s;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line"><span class="comment">//法二：</span></span><br><span class="line"><span class="comment">//可以直接把值插在位置i结点的后面，然后交换值(时间复杂度为O（1）)，假设已经知道i位置的结点Q,插入其前面的结点为s</span></span><br><span class="line"><span class="comment">//    s-&gt;next = Q-&gt;next;</span></span><br><span class="line"><span class="comment">//    Q-&gt;next = s;</span></span><br><span class="line"><span class="comment">//    ElemType temp = Q-&gt;data;</span></span><br><span class="line"><span class="comment">//    Q-&gt;data = s-&gt;data;</span></span><br><span class="line"><span class="comment">//    s-&gt;data = temp;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除位置i结点操作</span></span><br><span class="line"><span class="function">LinkList <span class="title">ListDelete</span><span class="params">(LinkList &amp;L, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line"><span class="comment">//法一：</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">    LinkList p = GetElem(L, i - <span class="number">1</span>); <span class="comment">//寻找前驱结点</span></span><br><span class="line">    LinkList q = p-&gt;next;   <span class="comment">//把q指向要删除结点</span></span><br><span class="line">    p-&gt;next = q-&gt;next;</span><br><span class="line">    ElemType e = q-&gt;data;</span><br><span class="line">    <span class="built_in">free</span>(q);    <span class="comment">//释放存储空间</span></span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line"><span class="comment">//法二：</span></span><br><span class="line"><span class="comment">//假设要删除Q点，可以把后继结点的值赋给自身（时间复杂度为O（1））</span></span><br><span class="line"><span class="comment">//    q = Q-&gt;next;</span></span><br><span class="line"><span class="comment">//    Q-&gt;data = Q-&gt;next-&gt;data;</span></span><br><span class="line"><span class="comment">//    Q-&gt;next = q-&gt;next;</span></span><br><span class="line"><span class="comment">//    free(q);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求表长长度</span></span><br><span class="line"><span class="function">ElemType <span class="title">ListLength</span><span class="params">(LinkList L)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    LinkList p = L;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p-&gt;next != <span class="literal">nullptr</span>) &#123;    <span class="comment">//（p-&gt;next != nullptr指下一个结点， p != nullptr指当前结点）</span></span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;个数为：&quot;</span> &lt;&lt; count &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出链表（针对有头结点的）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">List_show</span><span class="params">(LinkList &amp;L)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    LinkList p = L;</span><br><span class="line">    p = p-&gt;next;</span><br><span class="line"><span class="comment">//    do &#123;</span></span><br><span class="line"><span class="comment">//        cout &lt;&lt; p-&gt;data &lt;&lt; &quot; &quot;;</span></span><br><span class="line"><span class="comment">//        p = p-&gt;next;</span></span><br><span class="line"><span class="comment">//    &#125; while (L-&gt;next != nullptr);</span></span><br><span class="line">    <span class="keyword">int</span> m = ListLength(L);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; p-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">///////////////////////双链表/////////////////////////</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span> &#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span> *<span class="title">prior</span>, *<span class="title">next</span>;</span></span><br><span class="line">&#125; DNode, *DLinkList;</span><br><span class="line"></span><br><span class="line"><span class="comment">//双链表的按序号查找操作</span></span><br><span class="line"><span class="function">DLinkList <span class="title">DGetElem</span><span class="params">(DLinkList L, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line"><span class="comment">//..........................</span></span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//双链表的插入操作(头插法)</span></span><br><span class="line"><span class="function">DLinkList <span class="title">DListInsert</span><span class="params">(DLinkList &amp;L, <span class="keyword">int</span> i, ElemType e)</span> </span>&#123;</span><br><span class="line">    DLinkList p = DGetElem(L, i - <span class="number">1</span>);   <span class="comment">//在p后面插入s</span></span><br><span class="line">    DLinkList s;</span><br><span class="line">    s = (DLinkList) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DNode));</span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next-&gt;prior = s;</span><br><span class="line">    s-&gt;prior = p;</span><br><span class="line">    p-&gt;next = s;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//双链表的删除操作(头插法)</span></span><br><span class="line"><span class="function">DLinkList <span class="title">DListDelete</span><span class="params">(DLinkList &amp;L, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    DLinkList p = DGetElem(L, i - <span class="number">1</span>);   <span class="comment">//在p后面删除q</span></span><br><span class="line">    DLinkList q = p-&gt;next;</span><br><span class="line">    p-&gt;next = q-&gt;next;</span><br><span class="line">    q-&gt;next-&gt;prior = p;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//循环单/双链表******************</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">void 判空() &#123;</span></span><br><span class="line"><span class="comment">	LinkList M;</span></span><br><span class="line"><span class="comment">	DLinkList L;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">M-&gt;next == M;		//循环单链表判空</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">L-&gt;next == L;</span></span><br><span class="line"><span class="comment">L-&gt;prior == L;		//循环双链表判空</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//静态链表，用数组实现链式的存储方式(适用于不借助指针)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SDNode</span> &#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">&#125; SLinkList[MaxSize];</span><br><span class="line"></span><br><span class="line"><span class="comment">///////////////////第40页综合应用题//////////////////////////</span></span><br><span class="line"><span class="comment">//设计一个递归算法，删除不带头结点的单链表L中所有值为x的结点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test1_Delete_x</span><span class="params">(LinkList &amp;L, ElemType x)</span> </span>&#123;</span><br><span class="line"><span class="comment">//法一：交换前后值删除结点</span></span><br><span class="line">    <span class="keyword">if</span> (L-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (L-&gt;data == x) &#123;</span><br><span class="line">        LinkList p = L-&gt;next;</span><br><span class="line">        L-&gt;data = L-&gt;next-&gt;data;</span><br><span class="line">        L-&gt;next = p-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">        test1_Delete_x(L, x);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        test1_Delete_x(L-&gt;next, x);     <span class="comment">//这里不能先让 L=L-&gt;next，再把L代入test1_Delete_x，会导致所有结果都会消失，</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//法二：直接删除结点</span></span><br><span class="line"><span class="comment">//    LinkList p;</span></span><br><span class="line"><span class="comment">//    if (L-&gt;next == nullptr)</span></span><br><span class="line"><span class="comment">//        return;</span></span><br><span class="line"><span class="comment">//    if (L-&gt;data == x) &#123;</span></span><br><span class="line"><span class="comment">//        p = L;</span></span><br><span class="line"><span class="comment">//        L = L-&gt;next;</span></span><br><span class="line"><span class="comment">//        free(p);</span></span><br><span class="line"><span class="comment">//        test1_Delete_x(L, x);</span></span><br><span class="line"><span class="comment">//    &#125; else</span></span><br><span class="line"><span class="comment">//        test1_Delete_x(L-&gt;next, x);   //这里不能先让 L=L-&gt;next，再把L代入test1_Delete_x，会导致所有结果都会消失，</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在带头结点的单链表L中，删除所有值为x的结点，释放其空间</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test2_Delete_x</span><span class="params">(LinkList &amp;L, ElemType x)</span> </span>&#123;</span><br><span class="line"><span class="comment">//法一：由p从头扫描到尾，每一次都要连接前驱和后继</span></span><br><span class="line">    <span class="keyword">if</span> (L-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    LinkList p = L-&gt;next;</span><br><span class="line">    LinkList pre = L;   <span class="comment">//pre作为p的前驱，起连接作用</span></span><br><span class="line"><span class="comment">//    int Len = ListLength(L);</span></span><br><span class="line"><span class="comment">//    for (int i = 0; i &lt; Len; i++) &#123;</span></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;data == x) &#123;</span><br><span class="line">            LinkList q = p;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            pre-&gt;next = p;</span><br><span class="line">            <span class="built_in">free</span>(q);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pre = p;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//法二：采用尾插法建立单链表</span></span><br><span class="line"><span class="comment">//    LinkList p = L-&gt;next, r = L, q;</span></span><br><span class="line"><span class="comment">//    while (p != nullptr) &#123;</span></span><br><span class="line"><span class="comment">//        if (p-&gt;data != x) &#123;</span></span><br><span class="line"><span class="comment">//            r-&gt;next = p;</span></span><br><span class="line"><span class="comment">//            r = p;</span></span><br><span class="line"><span class="comment">//            p = p-&gt;next;</span></span><br><span class="line"><span class="comment">//        &#125; else &#123;</span></span><br><span class="line"><span class="comment">//            q = p;</span></span><br><span class="line"><span class="comment">//            p = p-&gt;next;</span></span><br><span class="line"><span class="comment">//            free(q);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//    r-&gt;next = nullptr;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//L为带头结点的单链表，实现反向输出每个结点的值</span></span><br><span class="line"><span class="comment">//本题为递归思想，也可以用逆置法，相当于尾插法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test3_Reverse_output</span><span class="params">(LinkList L)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L-&gt;next != <span class="literal">nullptr</span>)</span><br><span class="line">        test3_Reverse_output(L-&gt;next);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; L-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//带头结点的单链表L，删除其最小值的结点</span></span><br><span class="line"><span class="function">LinkList <span class="title">test4_Delete_min</span><span class="params">(LinkList &amp;L)</span> </span>&#123;</span><br><span class="line">    LinkList pre = L, p = pre-&gt;next, minpre = pre, minp = p;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;data &lt; minp-&gt;data) &#123;</span><br><span class="line">            minp = p;</span><br><span class="line">            minpre = pre;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = p;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    minpre-&gt;next = minp-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(minp);</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将一个带头结点的单链表就地逆置，即空间复杂度为O（1），即不能新建一个链表</span></span><br><span class="line"><span class="function">LinkList <span class="title">test5_Reverse_Local</span><span class="params">(LinkList &amp;L)</span> </span>&#123;</span><br><span class="line"><span class="comment">//法一：先把头结点摘下来，然后用头插法的方法从第一个结点开始吧结点插在头结点的后面</span></span><br><span class="line"><span class="comment">//    LNode *p, *r;</span></span><br><span class="line"><span class="comment">//    p = L-&gt;next;</span></span><br><span class="line"><span class="comment">//    L-&gt;next = nullptr;        //把头结点摘下</span></span><br><span class="line"><span class="comment">//    while (p != nullptr) &#123;</span></span><br><span class="line"><span class="comment">//        r = p-&gt;next;</span></span><br><span class="line"><span class="comment">//        p-&gt;next = L-&gt;next;</span></span><br><span class="line"><span class="comment">//        L-&gt;next = p;</span></span><br><span class="line"><span class="comment">//        p = r;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//    return L;</span></span><br><span class="line"><span class="comment">//法二：把各结点的指针反向指</span></span><br><span class="line">    LNode *pre, *p = L-&gt;next, *r = p-&gt;next;</span><br><span class="line">    p-&gt;next = <span class="literal">nullptr</span>;      <span class="comment">//这个要作为尾结点</span></span><br><span class="line">    <span class="keyword">while</span> (r != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        pre = p;</span><br><span class="line">        p = r;</span><br><span class="line">        r = r-&gt;next;</span><br><span class="line">        p-&gt;next = pre;</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;next = p;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使一个带头结点的单链表有序递增</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test6_increasing_order</span><span class="params">(LinkList &amp;L)</span> </span>&#123;</span><br><span class="line">    LinkList p = L-&gt;next, pre;</span><br><span class="line">    LinkList r = p-&gt;next;   <span class="comment">//r始终要为p的后继结点</span></span><br><span class="line">    p-&gt;next = <span class="literal">nullptr</span>;      <span class="comment">//从原链表断开，和头结点构造一个有序的链表</span></span><br><span class="line">    p = r;      <span class="comment">//令p指针指回还未排序的原链表</span></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        r = p-&gt;next;</span><br><span class="line">        pre = L;    <span class="comment">//pre始终要从头结点开始</span></span><br><span class="line">        <span class="keyword">while</span> (pre-&gt;next != <span class="literal">nullptr</span> &amp;&amp; p-&gt;next-&gt;data &lt; p-&gt;data)</span><br><span class="line">            pre = pre-&gt;next;</span><br><span class="line">        p-&gt;next = pre-&gt;next;</span><br><span class="line">        pre-&gt;next = p;</span><br><span class="line">        p = r;    <span class="comment">//令p指针指回还未排序的原链表</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//带头结点的无序单链表L，删除所有值在（s， e）之间的元素，不包括s和e</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test7_Delete_s_e</span><span class="params">(LinkList &amp;L, ElemType s, ElemType e)</span> </span>&#123;</span><br><span class="line">    LinkList p = L-&gt;next, pre = L;</span><br><span class="line">    <span class="keyword">if</span> (L-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;data &gt; s &amp;&amp; p-&gt;data &lt; e) &#123;</span><br><span class="line">            LinkList q = p;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            pre-&gt;next = p;</span><br><span class="line">            <span class="built_in">free</span>(q);</span><br><span class="line">            <span class="comment">//或者</span></span><br><span class="line"><span class="comment">//            pre-&gt;next = p-&gt;next;</span></span><br><span class="line"><span class="comment">//            free(p);</span></span><br><span class="line"><span class="comment">//            p = pre-&gt;next;</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pre = p;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//给定两个单链表，找出两个链表的公共结点(公共结点指某一时刻两个链表的某个节点-&gt;next会指向同一个结点，</span></span><br><span class="line"><span class="comment">// 并且之后的结点都是公共的，直到尾结点,会形成一个 Y 型)</span></span><br><span class="line"><span class="comment">//暴力法：逐个检查,时间复杂度为O（n?）</span></span><br><span class="line"><span class="comment">//线性时间复杂度法O（len1+len2）：先求出长度差，减去差后同步寻找</span></span><br><span class="line"><span class="function">LinkList <span class="title">test8_find_common_LNode</span><span class="params">(LinkList L1, LinkList L2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len1 = ListLength(L1), len2 = ListLength(L2);</span><br><span class="line">    LinkList longList, shortList;</span><br><span class="line">    <span class="keyword">int</span> dist;</span><br><span class="line">    <span class="keyword">if</span> (len1 &gt; len2) &#123;</span><br><span class="line">        longList = L1-&gt;next;</span><br><span class="line">        shortList = L2-&gt;next;</span><br><span class="line">        dist = len1 - len2;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        longList = L2-&gt;next;</span><br><span class="line">        shortList = L1-&gt;next;</span><br><span class="line">        dist = len2 - len1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (dist--)</span><br><span class="line">        longList = longList-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (longList != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (longList == shortList)</span><br><span class="line">            <span class="keyword">return</span> longList;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            longList = longList-&gt;next;</span><br><span class="line">            shortList = shortList-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LinkList L;</span><br><span class="line">    List_TailInsert(L);</span><br><span class="line"><span class="comment">//    cout &lt;&lt; &quot;输入要删除的值：&quot;;</span></span><br><span class="line"><span class="comment">//    ElemType x;</span></span><br><span class="line"><span class="comment">//    cin &gt;&gt; x;</span></span><br><span class="line"><span class="comment">//    test2_Delete_x(L, x);</span></span><br><span class="line">    test3_Reverse_output(L);</span><br><span class="line"><span class="comment">//    List_show(L);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>C++</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构_队列</title>
    <url>/2020/03/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h5 id="数据结构队列的实现！"><a href="#数据结构队列的实现！" class="headerlink" title="数据结构队列的实现！"></a>数据结构队列的实现！</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by XuYiMing on 2020/2/21.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElementType;</span><br><span class="line"></span><br><span class="line"><span class="comment">//*****************顺序/循环队列******************</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    ElementType data[MaxSize];</span><br><span class="line">    <span class="keyword">int</span> front, rear;</span><br><span class="line">&#125; SqQueue;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitQueue</span><span class="params">(SqQueue &amp;Q)</span> </span>&#123;        <span class="comment">//初始化</span></span><br><span class="line">    Q.rear = Q.front;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">(SqQueue Q)</span> </span>&#123;       <span class="comment">//判空</span></span><br><span class="line">    <span class="keyword">if</span> (Q.front == Q.rear)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">EnQueue</span><span class="params">(SqQueue &amp;Q, ElementType x)</span> </span>&#123;       <span class="comment">//入队</span></span><br><span class="line">    <span class="keyword">if</span> ((Q.rear + <span class="number">1</span>) % MaxSize == Q.front)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    Q.data[Q.rear] = x;</span><br><span class="line">    Q.rear = (Q.rear + <span class="number">1</span>) % MaxSize;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DeQueue</span><span class="params">(SqQueue &amp;Q, ElementType &amp;x)</span> </span>&#123;      <span class="comment">//出队</span></span><br><span class="line">    <span class="keyword">if</span> (Q.rear == Q.front)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    x = Q.data[Q.front];</span><br><span class="line">    Q.front = (Q.front + <span class="number">1</span>) % MaxSize;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//*******************链式存储队列****************</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span> &#123;</span></span><br><span class="line">    ElementType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; LinkNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    LinkNode *rear, *front;</span><br><span class="line">&#125; LinkQueue;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitLinkQueue</span><span class="params">(LinkQueue &amp;Q)</span> </span>&#123;</span><br><span class="line">    Q.front = Q.rear = (LinkNode *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));       <span class="comment">//建立头结点</span></span><br><span class="line">    Q.front-&gt;next = <span class="literal">nullptr</span>;        <span class="comment">//初始化为空</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsLinkEmpty</span><span class="params">(LinkQueue Q)</span> </span>&#123;     <span class="comment">//判空</span></span><br><span class="line">    <span class="keyword">if</span> (Q.front == Q.rear)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EnLinkQueue</span><span class="params">(LinkQueue &amp;Q, ElementType x)</span> </span>&#123;         <span class="comment">//入队</span></span><br><span class="line">    LinkNode *s = (LinkNode *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));</span><br><span class="line">    s-&gt;data = x;</span><br><span class="line">    s-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    Q.rear-&gt;next = s;</span><br><span class="line">    Q.rear = s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DeLinkQueue</span><span class="params">(LinkQueue &amp;Q, ElementType &amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Q.rear == Q.front)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    LinkNode *p = Q.front-&gt;next;</span><br><span class="line">    x = p-&gt;data;</span><br><span class="line">    Q.front-&gt;next = p-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> (Q.rear == p)</span><br><span class="line">        Q.rear = Q.front;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>C++</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构_顺序表</title>
    <url>/2020/02/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%A1%BA%E5%BA%8F%E8%A1%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h5 id="数据结构顺序表的实现！"><a href="#数据结构顺序表的实现！" class="headerlink" title="数据结构顺序表的实现！"></a>数据结构顺序表的实现！</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Created by XuYiMing on 2020/2/2.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">////////////////////顺序表///////////////////////////</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> InitSize 1000        <span class="comment">//表长初始定义</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;       <span class="comment">//在此例中数据类型使用int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span>            <span class="comment">//顺序表的定义</span></span><br><span class="line">    ElemType *data;         <span class="comment">//指示动态分配数组的指针</span></span><br><span class="line">    <span class="keyword">int</span> length;             <span class="comment">//表当前长度</span></span><br><span class="line">    <span class="keyword">int</span> MaxSize;            <span class="comment">//表当前分配的最大长度</span></span><br><span class="line">&#125; SeqList;                  <span class="comment">//动态分配数组顺序表的类型定义</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">InitList</span><span class="params">(SeqList &amp;L)</span> </span>&#123;   <span class="comment">//初始化线性表，这里如果采用SeqList *L，则调用时则为 L-&gt;data</span></span><br><span class="line">    L.data = (ElemType *) <span class="built_in">malloc</span>(InitSize * <span class="keyword">sizeof</span>(ElemType));  <span class="comment">//这里数组是从0开始的，如果从1开始，则要为(InitSize+1)</span></span><br><span class="line">    <span class="keyword">if</span> (L.data == <span class="literal">nullptr</span>) &#123;    <span class="comment">//nullptr表示空指针，在C++中可以避免二义性问题</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;内存分配错误！\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    L.length = <span class="number">0</span>;</span><br><span class="line">    L.MaxSize = InitSize;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;内存分配成功！\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListInsert</span><span class="params">(SeqList &amp;L, <span class="keyword">int</span> i, ElemType e)</span> </span>&#123;     <span class="comment">//线性表的插入，在指定位置插入某值(1&lt;=i&lt;=L.length)</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; L.length + <span class="number">1</span>) &#123;      <span class="comment">//这里的i表示的是逻辑上的位置，而实际存储的是物理上的位置</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;插入位置不合理！\n&quot;</span>); <span class="comment">//判断插入的地址是否为负数或有间隔</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= L.MaxSize) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;存储空间已满！\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = L.length; j &gt;= i; j--) &#123;       <span class="comment">//平均插入时间为O(n)</span></span><br><span class="line">        L.data[j] = L.data[j - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    L.data[i - <span class="number">1</span>] = e;</span><br><span class="line">    L.length++;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListDelete</span><span class="params">(SeqList &amp;L, <span class="keyword">int</span> i, ElemType &amp;e)</span> </span>&#123;     <span class="comment">//线性表的删除，在指定位置删除某值(1&lt;=i&lt;=L.length)</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; L.length + <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;删除位置不合理！\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    e = L.data[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= L.length; j++) &#123;           <span class="comment">//平均删除时间为O(n)</span></span><br><span class="line">        L.data[j - <span class="number">1</span>] = L.data[j];</span><br><span class="line">    &#125;</span><br><span class="line">    L.length--;</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListLength</span><span class="params">(SeqList &amp;L)</span> </span>&#123;        <span class="comment">//求表长，计算元素个数</span></span><br><span class="line">    <span class="keyword">if</span> (L.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;元素个数为0&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; L.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (L.data[i]) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">locateElem</span><span class="params">(SeqList &amp;L, ElemType e)</span> </span>&#123;    <span class="comment">//按值查找逻辑下标</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; L.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (L.data[i] == e) &#123;</span><br><span class="line">            <span class="keyword">return</span> i + <span class="number">1</span>;       <span class="comment">//返回逻辑位置</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetElem</span><span class="params">(SeqList &amp;L, <span class="keyword">int</span> i)</span> </span>&#123;    <span class="comment">//按位置查找</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; L.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> L.data[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintList</span><span class="params">(SeqList L)</span> </span>&#123;    <span class="comment">//从前到后输出值</span></span><br><span class="line">    <span class="keyword">if</span> (L.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;顺序表为空&quot;</span>;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;顺序表如下：&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; L.length; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; %d&quot;</span>, L.data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////第19页综合应用题////////////////////</span></span><br><span class="line"><span class="comment">//顺序表删除最小值，把最后一个值填补最小值的位置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">test1</span><span class="params">(SeqList &amp;L, ElemType &amp;value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    value = L.data[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; L.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (L.data[i] &lt; value) &#123;</span><br><span class="line">            value = L.data[i];</span><br><span class="line">            pos = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    L.data[pos] = L.data[L.length - <span class="number">1</span>];</span><br><span class="line">    L.length--;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//把顺序表逆置，要求时间复杂度为O(1)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test2</span><span class="params">(SeqList &amp;L)</span> </span>&#123;</span><br><span class="line">    ElemType temp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; L.length / <span class="number">2</span>; i++) &#123;</span><br><span class="line">        temp = L.data[i];</span><br><span class="line">        L.data[i] = L.data[L.length - i - <span class="number">1</span>];</span><br><span class="line">        L.data[L.length - i - <span class="number">1</span>] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线性表删除所有值为x的数据元素，要求时间复杂度O(n),空间复杂度O(1)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test3</span><span class="params">(SeqList &amp;L, ElemType x)</span> </span>&#123;</span><br><span class="line"><span class="comment">//法一</span></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; L.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (L.data[i] != x) &#123;</span><br><span class="line">            L.data[k] = L.data[i];</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    L.length = k;</span><br><span class="line"><span class="comment">//法二</span></span><br><span class="line"><span class="comment">//    int k = 0, i = 0;</span></span><br><span class="line"><span class="comment">//    while (i &lt; L.length) &#123;</span></span><br><span class="line"><span class="comment">//        if (L.data[i] == x) &#123;</span></span><br><span class="line"><span class="comment">//            k++;</span></span><br><span class="line"><span class="comment">//        &#125; else &#123;</span></span><br><span class="line"><span class="comment">//            L.data[i - k] = L.data[i];</span></span><br><span class="line"><span class="comment">//            i++;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//    L.length -= k;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//有序顺序表中，删除元素的值在s和t之间的所有元素(不包括s和t)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">test4</span><span class="params">(SeqList &amp;L, ElemType s, ElemType t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">if</span> (s &gt;= t || L.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; L.length &amp;&amp; L.data[i] &lt; s; i++);</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= L.length)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (j = i; j &lt; L.length &amp;&amp; L.data[j] &lt;= t; j++);</span><br><span class="line">    <span class="keyword">for</span> (; j &lt; L.length; i++, j++)</span><br><span class="line">        L.data[i] = L.data[j];</span><br><span class="line">    L.length = i;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//顺序表中，删除元素的值在s和t之间的所有元素(包括s和t)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">test5</span><span class="params">(SeqList &amp;L, ElemType s, ElemType t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (L.length == <span class="number">0</span> || s &gt;= t)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; L.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (L.data[i] &gt;= s &amp;&amp; L.data[i] &lt;= t)</span><br><span class="line">            k++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            L.data[i - k] = L.data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    L.length -= k;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除有序顺序表中重复的元素，使其值均不同</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">test6</span><span class="params">(SeqList &amp;L)</span> </span>&#123;</span><br><span class="line"><span class="comment">//法一</span></span><br><span class="line">    <span class="keyword">if</span> (L.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i, k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; L.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (L.data[i] == L.data[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            k++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            L.data[i - k] = L.data[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    L.length -= k;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//法二</span></span><br><span class="line"><span class="comment">//    if (L.length == 0)</span></span><br><span class="line"><span class="comment">//        return 0;</span></span><br><span class="line"><span class="comment">//    int i, j;</span></span><br><span class="line"><span class="comment">//    for (i = 0, j = 1; j &lt; L.length; j++) &#123;</span></span><br><span class="line"><span class="comment">//        if (L.data[i] != L.data[j])</span></span><br><span class="line"><span class="comment">//            L.data[++i] = L.data[j];</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//    L.length = i + 1;</span></span><br><span class="line"><span class="comment">//    return 1;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//合并两个有序顺序表为一个有序顺序表</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">test7</span><span class="params">(SeqList &amp;L1, SeqList &amp;L2, SeqList &amp;L3)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L1.length + L2.length &gt; L3.MaxSize) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; L1.length &amp;&amp; j &lt; L2.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (L1.data[i] &lt;= L2.data[j]) &#123;</span><br><span class="line">            L3.data[k++] = L1.data[i++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            L3.data[k++] = L2.data[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; L1.length) &#123;</span><br><span class="line">        L3.data[k++] = L1.data[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (j &lt; L2.length) &#123;</span><br><span class="line">        L3.data[k++] = L2.data[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    L3.length = k;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将数组A[m+n]中两个序列表位置整体互换</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Reverse</span><span class="params">(ElemType A[], <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> ArraySize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right || right &gt;= ArraySize) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mid - left; i++) &#123;</span><br><span class="line">        ElemType temp = A[i];</span><br><span class="line">        A[i] = A[right - i];</span><br><span class="line">        A[right - <span class="number">1</span>] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test8</span><span class="params">(ElemType A[], <span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> ArraySize)</span> </span>&#123;</span><br><span class="line">    Reverse(A, <span class="number">0</span>, m + n - <span class="number">1</span>, ArraySize);</span><br><span class="line">    Reverse(A, <span class="number">0</span>, n - <span class="number">1</span>, ArraySize);</span><br><span class="line">    Reverse(A, n, m + n - <span class="number">1</span>, ArraySize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用最少时间的方法查找x，找到则与后继交换位置，没找到则插入且任然递增有序</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">test8</span><span class="params">(ElemType A[], ElemType x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>, high = n - <span class="number">1</span>, mid;</span><br><span class="line">    mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;       <span class="comment">//二分法</span></span><br><span class="line">        <span class="keyword">if</span> (A[mid] == x)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (A[mid] &lt; x)</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (A[mid] == x &amp;&amp; mid != n - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> t = A[mid];</span><br><span class="line">        A[mid] = A[mid + <span class="number">1</span>];</span><br><span class="line">        A[mid + <span class="number">1</span>] = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//不管是比A[0]小还是比A[n-1]大，都可以插入；因为当在A[0，n-1]之间找不到时，最后会出现low&gt;high的情况</span></span><br><span class="line">    <span class="keyword">if</span> (low &gt; high) &#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = n - <span class="number">1</span>; i &gt; high; i--) &#123;</span><br><span class="line">            A[i + <span class="number">1</span>] = A[i];</span><br><span class="line">        &#125;</span><br><span class="line">        A[i + <span class="number">1</span>] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SeqList L;</span><br><span class="line">    InitList(L);</span><br><span class="line">    <span class="keyword">int</span> i, e;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入元素个数：&quot;</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; L.length;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; L.length; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;L.data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    PrintList(L);</span><br><span class="line"><span class="comment">//    cout &lt;&lt; &quot;test6&quot;;</span></span><br><span class="line"><span class="comment">//    test6(L);</span></span><br><span class="line"><span class="comment">//    PrintList(L);</span></span><br><span class="line"><span class="comment">//    cout &lt;&lt; &quot;请输入插入的位置和插入的元素：&quot;;</span></span><br><span class="line"><span class="comment">//    scanf(&quot;%d%d&quot;, &amp;i, &amp;e);</span></span><br><span class="line"><span class="comment">//    ListInsert(L, i, e);</span></span><br><span class="line"><span class="comment">//    PrintList(L);</span></span><br><span class="line"><span class="comment">//    cout &lt;&lt; &quot;请输入删除的位置：&quot;;</span></span><br><span class="line"><span class="comment">//    scanf(&quot;%d&quot;, &amp;i);</span></span><br><span class="line"><span class="comment">//    ListDelete(L, i, e);</span></span><br><span class="line"><span class="comment">//    cout &lt;&lt; e &lt;&lt; &quot;被删除了!&quot;;</span></span><br><span class="line"><span class="comment">//    PrintList(L);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>C++</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>java面试笔记</title>
    <url>/2021/03/18/java%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>[TOC]</p>
<h3 id="面向过程-POP-与面向对象-OOP"><a href="#面向过程-POP-与面向对象-OOP" class="headerlink" title="面向过程(POP)与面向对象(OOP)"></a>面向过程(POP)与面向对象(OOP)</h3><ul>
<li><p>面向过程，强调的是功能行为，以函数为最小单位，考虑怎么做。</p>
</li>
<li><p>面向对象，将功能封装进对象，强调具备了功能的对象，以类/对象为最小单位，考虑谁来做。面向对象更加强调运用人类在日常的思维逻辑中采用的思想方法与原则，如抽象、分类、继承、聚合、多态等。易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护。</p>
</li>
</ul>
<h3 id="对象内存解析：堆、栈、方法区"><a href="#对象内存解析：堆、栈、方法区" class="headerlink" title="对象内存解析：堆、栈、方法区"></a>对象内存解析：堆、栈、方法区</h3><ul>
<li><p>堆（Heap），此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。这一点在Java虚拟机规范中的描述是：所有的对象实例以及数组都要在堆上分配。 通常所说的栈（Stack），是指虚拟机</p>
</li>
<li><p>栈，（Stack）虚拟机栈用于存储局部变量等。局部变量表存放了编译期可知长度的各种基本数据类型（boolean、byte、char 、 short 、 int 、 float 、 long 、double）、对象引用（reference类型，它不等同于对象本身，是对象在堆内存的首地址）。 方法执行完，自动释放。</p>
</li>
<li><p>方法区（Method Area），用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p>
</li>
</ul>
<h3 id="局部变量和成员变量的区别"><a href="#局部变量和成员变量的区别" class="headerlink" title="局部变量和成员变量的区别"></a>局部变量和成员变量的区别</h3><table>
<thead>
<tr>
<th></th>
<th><strong>成员变量</strong></th>
<th><strong>局部变量</strong></th>
</tr>
</thead>
<tbody><tr>
<td>声明的位置</td>
<td>直接声明在类中</td>
<td>方法形参或内部、代码块内、构造器内等</td>
</tr>
<tr>
<td>修饰符</td>
<td>private、public、static、final等</td>
<td>不能用权限修饰符修饰，可以用final修饰</td>
</tr>
<tr>
<td>初始化值</td>
<td>有默认初始化值</td>
<td>没有默认初始化值，必须显式赋值，方可使用</td>
</tr>
<tr>
<td>内存加载位置</td>
<td>堆空间 或 静态域内</td>
<td>栈空间</td>
</tr>
</tbody></table>
<h3 id="高内聚、低耦合"><a href="#高内聚、低耦合" class="headerlink" title="高内聚、低耦合"></a>高内聚、低耦合</h3><ul>
<li>高内聚 ：类的内部数据操作细节自己完成，不允许外部干涉。</li>
<li>低耦合 ：仅对外暴露少量的方法用于使用。</li>
</ul>
<h3 id="四种访问权限修饰符"><a href="#四种访问权限修饰符" class="headerlink" title="四种访问权限修饰符"></a>四种访问权限修饰符</h3><table>
<thead>
<tr>
<th align="center">修饰符</th>
<th align="center">类内部</th>
<th align="center">同一个包</th>
<th align="center">不同包的子类</th>
<th align="center">同一个工程</th>
</tr>
</thead>
<tbody><tr>
<td align="center">private</td>
<td align="center">Yes</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">default（缺省）</td>
<td align="center">Yes</td>
<td align="center">Yes</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">protected</td>
<td align="center">Yes</td>
<td align="center">Yes</td>
<td align="center">Yes</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">public</td>
<td align="center">Yes</td>
<td align="center">Yes</td>
<td align="center">Yes</td>
<td align="center">Yes</td>
</tr>
</tbody></table>
<h3 id="this和super的区别"><a href="#this和super的区别" class="headerlink" title="this和super的区别"></a>this和super的区别</h3><table>
<thead>
<tr>
<th>No.</th>
<th>区别点</th>
<th>this</th>
<th>super</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>访问属性</td>
<td>访问本类中的属性，如果本类没有此属性则从父类中继续查找</td>
<td>直接访问父类中的属性</td>
</tr>
<tr>
<td>2</td>
<td>调用方法</td>
<td>访问本类中的方法，如果本类没有此方法则从父类中继续查找</td>
<td>直接访问父类中的方法</td>
</tr>
<tr>
<td>3</td>
<td>调用构造器</td>
<td>调用本类构造器，必须放在构造器的首行</td>
<td>调用父类构造器，必须放在子类构造器的首行</td>
</tr>
</tbody></table>
<h3 id="方法重载和重写的区别"><a href="#方法重载和重写的区别" class="headerlink" title="方法重载和重写的区别"></a>方法重载和重写的区别</h3><ul>
<li><p>重载：</p>
<p>发生在同一个类中，方法名必须相同，参数的类型、个数、顺序至少要有一项不同，方法的返回值和访问修饰符可以不同，发生在编译时。</p>
</li>
<li><p>重写：</p>
<p>发生在父类和子类中。</p>
<p>子类重写的方法和父类被重写的方法要有相同的方法名、参数列表。</p>
<p>子类重写的方法的返回值类型不能大于父类被重写的方法的返回值类型。</p>
<p>子类重写的方法使用的访问权限不能小于父类被重写的方法的访问权限。</p>
<p>子类方法抛出的异常不能大于父类被重写方法的异常。</p>
<p>子类不能重写父类中声明为private权限的方法。</p>
<p>发生在运行时，动态绑定，只有等到方法调用的那一刻，解释运行器才会确定所要调用的具体方法。</p>
</li>
</ul>
<h3 id="操作符与-equals-方法"><a href="#操作符与-equals-方法" class="headerlink" title="==  操作符与 equals 方法"></a>==  操作符与 equals 方法</h3><ul>
<li>== 既可以比较基本类型也可以比较引用类型。对于基本类型就是比较值，对于引用类型就是比较内存地址</li>
<li>equals 只能用于比较引用类型，比较是否指向同一个对象。<ul>
<li>特例：当用 equals() 方法进行比较时，对类File、String、Date及包装类（Wrapper Class）来说，是比较类型及内容而不考虑引用的是否是同一个对象；</li>
<li>原因：在这些类中重写了 Object 类的 equals() 方法。</li>
</ul>
</li>
<li>具体要看自定义类里有没有重写Object的equals方法来判断。</li>
<li>通常情况下，重写equals方法，会比较类中的相应属性是否都相等。</li>
</ul>
<h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><p>被修饰后的成员具备以下特点：</p>
<ul>
<li>static可以修饰属性、 方法、代码块、内部类</li>
<li>随着类的加载而加载</li>
<li>优先于对象存在</li>
<li>修饰的成员，被所有对象所共享</li>
<li>访问权限允许时，可不创建对象，直接被类调用</li>
<li>在static方法内部只能访问类的static修饰的属性或方法，不能访问类的非static的结构</li>
<li>因为不需要实例就可以访问static方法，因此static方法内部不能有this，也不能有super</li>
<li>没有对象的实例时，可以用 “类名.方法名()” 的形式访问由static修饰的类方法</li>
</ul>
<h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><ul>
<li>final 标记的类不能被继承。提高安全性，提高程序的可读性。 </li>
<li>final 标记的方法不能被子类重写</li>
<li>final 标记的变量(成员变量或局部变量)即称为常量，名称大写，且只能被赋值一次<ul>
<li>final 标记的成员变量必须在声明时或在每个构造器中或代码块中显式赋值，然后才能使用。 </li>
<li>例如：final double MY_PI = 3.14</li>
</ul>
</li>
</ul>
<h3 id="抽象类和抽象方法"><a href="#抽象类和抽象方法" class="headerlink" title="抽象类和抽象方法"></a>抽象类和抽象方法</h3><ul>
<li>用abstract关键字来修饰一个类，这个类叫做抽象类；用abstract来修饰一个方法，该方法叫做抽象方法。 </li>
<li>抽象方法：只有方法的声明，没有方法的实现。以分号结束：比如：public abstract void talk()</li>
<li>含有抽象方法的类必须被声明为抽象类。</li>
<li>抽象类不能被实例化。抽象类是用来被继承的，抽象类的子类必须重写父类的抽象方法，并提供方法体。若没有重写全部的抽象方法，仍为抽象类。</li>
<li>不能用abstract修饰变量、代码块、构造器；</li>
<li>不能用abstract修饰私有方法、静态方法、final的方法、final的类。</li>
</ul>
<h3 id="interface"><a href="#interface" class="headerlink" title="interface"></a>interface</h3><ul>
<li><p>接口(interface)是抽象方法和常量值定义的集合。 </p>
</li>
<li><p>接口的特点：</p>
<ul>
<li>用interface来定义。 </li>
<li>接口中的所有成员变量都默认是由public static final修饰的。 </li>
<li>接口中的所有抽象方法都默认是由public abstract修饰的。 </li>
<li>接口中没有构造器。 </li>
<li>接口采用多继承机制。</li>
</ul>
</li>
</ul>
<h3 id="接口和抽象类的对比"><a href="#接口和抽象类的对比" class="headerlink" title="接口和抽象类的对比"></a>接口和抽象类的对比</h3><table>
<thead>
<tr>
<th>No.</th>
<th>区别点</th>
<th>抽象类</th>
<th>接口</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>定义</td>
<td>包含抽象方法的类</td>
<td>主要是抽象方法和全局常量的集合</td>
</tr>
<tr>
<td>2</td>
<td>组成</td>
<td>构造方法、抽象方法、普通方法、</td>
<td>常量、变量 常量、抽象方法、(jdk8.0:默认方法、静态方法)</td>
</tr>
<tr>
<td>3</td>
<td>使用</td>
<td>子类继承抽象类(extends)</td>
<td>子类实现接口(implements)</td>
</tr>
<tr>
<td>4</td>
<td>关系</td>
<td>抽象类可以实现多个接口</td>
<td>接口不能继承抽象类，但允许继承多个接口</td>
</tr>
<tr>
<td>5</td>
<td>常见设计模式</td>
<td>模板方法</td>
<td>简单工厂、工厂方法、代理模式</td>
</tr>
<tr>
<td>6</td>
<td>对象</td>
<td>都通过对象的多态性产生实例化对象</td>
<td>都通过对象的多态性产生实例化对象</td>
</tr>
<tr>
<td>7</td>
<td>局限</td>
<td>抽象类有单继承的局限</td>
<td>接口没有此局限</td>
</tr>
<tr>
<td>8</td>
<td>实际</td>
<td>作为一个模板</td>
<td>是作为一个标准或是表示一种能力</td>
</tr>
<tr>
<td>9</td>
<td>选择</td>
<td>如果抽象类和接口都可以使用的话，优先使用接口，因为避免单继承的局限</td>
<td>如果抽象类和接口都可以使用的话，优先使用接口，因为避免单继承的局限</td>
</tr>
</tbody></table>
<h3 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h3><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/xyming108/blog_img/raw/master/post/image-20210228172449935.png" />

<h3 id="15、API-中创建线程的方式"><a href="#15、API-中创建线程的方式" class="headerlink" title="15、API 中创建线程的方式"></a>15、API 中创建线程的方式</h3><ul>
<li><p>方式一：继承Thread类</p>
<ul>
<li><p>定义子类继承Thread类</p>
</li>
<li><p>子类中重写Thread类中的run方法</p>
</li>
<li><p>创建Thread子类对象，即创建了线程对象</p>
</li>
<li><p>调用线程对象start方法：启动线程，调用run方法</p>
</li>
<li><p>一个线程对象只能调用一次start()方法启动，如果重复调用了，则将抛出以上</p>
<p>的异常 “IllegalThreadStateException”</p>
</li>
<li><p>Thread 类的有关方法</p>
<ul>
<li>void start()：启动线程，并执行对象的run()方法</li>
<li>run()：线程在被调度时执行的操作</li>
<li>String getName()：返回线程的名称</li>
<li>void setName(String name)：设置该线程名称</li>
<li>static Thread currentThread()：返回当前线程。在Thread子类中就是this，通常用于主线程和Runnable实现类</li>
<li>static void yield()：线程让步<ul>
<li>暂停当前正在执行的线程，把执行机会让给优先级相同或更高的线程</li>
<li>若队列中没有同优先级的线程，忽略此方法</li>
</ul>
</li>
<li>join() ：当某个程序执行流中调用其他线程的 join() 方法时，调用线程将被阻塞，直到 join() 方法加入的 join 线程执行完为止<ul>
<li>低优先级的线程也可以获得执行</li>
</ul>
</li>
<li>static void sleep(long millis)：(指定时间:毫秒) <ul>
<li>令当前活动线程在指定时间段内放弃对CPU控制,使其他线程有机会被执行,时间到后重排队。</li>
<li>抛出InterruptedException异常</li>
</ul>
</li>
<li>stop()：强制线程生命期结束，不推荐使用</li>
<li>boolean isAlive()：返回boolean，判断线程是否还活着</li>
</ul>
</li>
</ul>
</li>
<li><p>方式二：实现 Runnable 接口</p>
<ul>
<li>定义子类，实现Runnable接口</li>
<li>子类中重写Runnable接口中的run方法</li>
<li>通过Thread类含参构造器创建线程对象</li>
<li>将Runnable接口的子类对象作为实际参数传递给Thread类的构造器中</li>
<li> 调用Thread类的start方法：开启线程，调用Runnable子类接口的run方法</li>
</ul>
</li>
<li><p>方式三：实现Callable接口（JDK5.0新增线程创建方式）</p>
<ul>
<li>与使用Runnable相比， Callable功能更强大些<ul>
<li>相比run()方法，可以有返回值</li>
<li>方法可以抛出异常</li>
<li>支持泛型的返回值</li>
<li>需要借助FutureTask类，比如获取返回结果<ul>
<li>Future接口<ul>
<li>FutrueTask是Futrue接口的唯一的实现类</li>
<li>可以对具体Runnable、Callable任务的执行结果进行取消、查询是否完成、获取结果等。</li>
<li>FutureTask 同时实现了Runnable, Future接口。它既可以作为Runnable被线程执行，又可以作为Future得到Callable的返回值</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>方式四：使用线程池</p>
<ul>
<li>背景：经常创建和销毁、使用量特别大的资源，比如并发情况下的线程，对性能影响很大。 </li>
<li>思路：提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中。可以避免频繁创建销毁、实现重复利用。类似生活中的公共交通工具。</li>
<li>好处：<ul>
<li>提高响应速度（减少了创建新线程的时间）</li>
<li>降低资源消耗（重复利用线程池中线程，不需要每次都创建）</li>
<li>便于线程管理<ul>
<li>corePoolSize：核心池的大小</li>
<li>maximumPoolSize：最大线程数 </li>
<li>keepAliveTime：线程没有任务时最多保持多长时间后会终止</li>
<li>…</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="多线程的安全问题解决方式：同步机制"><a href="#多线程的安全问题解决方式：同步机制" class="headerlink" title="多线程的安全问题解决方式：同步机制"></a>多线程的安全问题解决方式：同步机制</h3><ul>
<li>synchornized锁：<ul>
<li>同步代码块：synchornized( 对象 ) { 需要被同步的代码; }</li>
<li>synchronized 还可以放在方法声明中，表示整个方法为同步方法</li>
<li>当前线程在同步代码块、同步方法中执行了线程对象的 wait() 方法，当前线程暂停，并释放锁</li>
<li>线程执行同步代码块或同步方法时，程序调用Thread.sleep()、Thread.yield()方法暂停当前线程的执行，但不释放锁</li>
</ul>
</li>
<li>Lock锁：<ul>
<li>开启锁：lock.lock();</li>
<li>关闭锁：lock.unlock();</li>
</ul>
</li>
</ul>
<h3 id="synchronized与Lock的对比"><a href="#synchronized与Lock的对比" class="headerlink" title="synchronized与Lock的对比"></a>synchronized与Lock的对比</h3><ul>
<li>Lock是显式锁（手动开启和关闭锁，别忘记关闭锁），synchronized是隐式锁，出了作用域自动释放</li>
<li>Lock只有代码块锁，synchronized有代码块锁和方法锁</li>
<li>使用Lock锁，JVM将花费较少的时间来调度线程，性能更好。并且具有更好的扩展性（提供更多的子类）</li>
</ul>
<h3 id="对比String、StringBuffer、StringBuilder"><a href="#对比String、StringBuffer、StringBuilder" class="headerlink" title="对比String、StringBuffer、StringBuilder"></a>对比String、StringBuffer、StringBuilder</h3><ul>
<li>String(JDK1.0)：不可变字符序列</li>
<li>StringBuffer(JDK1.0)：可变字符序列、效率低、线程安全</li>
<li>StringBuilder(JDK 5.0)：可变字符序列、效率高、线程不安全</li>
<li>注意：作为参数传递的话，方法内部String不会改变其值，StringBuffer和StringBuilder会改变其值。</li>
</ul>
<h3 id="comparable和comparator"><a href="#comparable和comparator" class="headerlink" title="comparable和comparator"></a>comparable和comparator</h3><ul>
<li>ccomparable：实现 Comparable 的类必须实现 compareTo(Object obj) 方法，两个对象即通过 compareTo(Object obj) 方法的返回值来比较大小。如果当前对象this大 于形参对象obj，则返回正整数，如果当前对象this小于形参对象obj，则返回负整数，如果当前对象this等于形参对象obj，则返回零。</li>
<li>comparator：重写compare(Object o1,Object o2)方法，比较o1和o2的大小：如果方法返回正整数，则表示o1大于o2；如果返回0，表示相等；返回负整数，表示o1小于o2。</li>
</ul>
<h3 id="Collection-和-Map"><a href="#Collection-和-Map" class="headerlink" title="Collection 和 Map"></a>Collection 和 Map</h3><p>Collection接口：单列数据，定义了存取一组对象的方法的集合</p>
<pre><code>    List：元素有序、可重复的集合

    Set：元素无序、不可重复的集合
</code></pre>
<p>Map接口：双列数据，保存具有映射关系“key-value对”的集合</p>
<img src= "/img/loading.gif" data-lazy-src="https://gitee.com/xyming108/blog_img/raw/master/post/image-20210228214649768.png" />

<img src= "/img/loading.gif" data-lazy-src="https://gitee.com/xyming108/blog_img/raw/master/post/image-20210228214712019.png" />

<h3 id="ArrayList、LinkedList、Vector-比较"><a href="#ArrayList、LinkedList、Vector-比较" class="headerlink" title="ArrayList、LinkedList、Vector 比较"></a>ArrayList、LinkedList、Vector 比较</h3><ul>
<li><p>List集合类中元素有序、且可重复，集合中的每个元素都有其对应的顺序索引</p>
</li>
<li><p>JDK1.7：ArrayList像饿汉式，直接创建一个初始容量为10的数组</p>
</li>
<li><p>JDK1.8：ArrayList像懒汉式，一开始创建一个长度为0的数组，当添加第一个元素时再创建一个始容量为10的数组</p>
</li>
<li><p>ArrayList和LinkedList的异同</p>
<p>二者都线程不安全，比线程安全的Vector执行效率更高。</p>
<p>此外，ArrayList是实现了基于动态数组的数据结构，LinkedList基于双向链表的数据结构。</p>
<p>对于随机访问get和set，ArrayList绝对优于LinkedList，因为LinkedList要移动指针。</p>
<p>对于新增和删除操作add(特指插入)和remove，LinkedList比较占优势，因为ArrayList要移动数据。</p>
</li>
<li><p>ArrayList和Vector的区别</p>
<p>Vector和ArrayList几乎是完全相同的,唯一的区别在于Vector是同步类(synchronized)，属于强同步类。因此开销就比ArrayList要大，访问要慢。正常情况下,大多数的Java程序员使用ArrayList而不是Vector,因为同步完全可以由程序员自己来控制。Vector每次扩容请求其大小的2倍空间，而ArrayList是1.5倍。Vector还有一个子类Stack</p>
</li>
</ul>
<h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/xyming108/blog_img/raw/master/post/image-20210302202652221.png" />

<img src= "/img/loading.gif" data-lazy-src="https://gitee.com/xyming108/blog_img/raw/master/post/image-20210302202714926.png" />

<h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/xyming108/blog_img/raw/master/post/image-20210302203048564.png" />

<img src= "/img/loading.gif" data-lazy-src="https://gitee.com/xyming108/blog_img/raw/master/post/image-20210302203125800.png" />

<img src= "/img/loading.gif" data-lazy-src="https://gitee.com/xyming108/blog_img/raw/master/post/image-20210302203316725.png" />

<img src= "/img/loading.gif" data-lazy-src="https://gitee.com/xyming108/blog_img/raw/master/post/image-20210302203414123.png" />

<h3 id="HashMap与HashTable"><a href="#HashMap与HashTable" class="headerlink" title="HashMap与HashTable"></a>HashMap与HashTable</h3><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/xyming108/blog_img/raw/master/post/image-20210302203503624.png" />

<h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><p><a href="https://www.yycoding.xyz/post/2014/3/27/introduce-red-black-tree">https://www.yycoding.xyz/post/2014/3/27/introduce-red-black-tree</a></p>
<h3 id="InnoDB，MyISAM区别"><a href="#InnoDB，MyISAM区别" class="headerlink" title="InnoDB，MyISAM区别"></a>InnoDB，MyISAM区别</h3><p>1）InnoDB支持事务，MyISAM不支持，这一点是非常之重要。事务是一种高级的处理方式，如在一些列增删改中只要哪个出错还可以回滚还原，而MyISAM就不可以了。<br>2）MyISAM适合查询以及插入为主的应用，InnoDB适合频繁修改以及涉及到安全性较高的应用<br>3）InnoDB支持外键，MyISAM不支持<br>4）从MySQL5.5.5以后，InnoDB是默认引擎<br>5）InnoDB不支持FULLTEXT类型的索引<br>6）InnoDB中不保存表的行数，如select count() from table时，InnoDB需要扫描一遍整个表来计算有多少行，但是MyISAM只要简单的读出保存好的行数即可。注意的是，当count()语句包含where条件时MyISAM也需要扫描整个表<br>7）对于自增长的字段，InnoDB中必须包含只有该字段的索引，但是在MyISAM表中可以和其他字段一起建立联合索引<br>8）清空整个表时，InnoDB是一行一行的删除，效率非常慢。MyISAM则会重建表<br>9）InnoDB支持行锁（某些情况下还是锁整表，如 update table set a=1 where user like ‘％lee％’。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql学习笔记Day4</title>
    <url>/2021/03/18/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0Day4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>[TOC]</p>
<h1 id="Day4"><a href="#Day4" class="headerlink" title="Day4"></a><strong>Day4</strong></h1><h3 id="1、DML语言"><a href="#1、DML语言" class="headerlink" title="1、DML语言"></a><strong>1、DML语言</strong></h3><h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">语法：</span><br><span class="line">	方式一：（支持插入多行，子查询）</span><br><span class="line">		insert into 表名(字段名，...)</span><br><span class="line">		values(值1，...), (值1，...), ......;</span><br><span class="line">	方式二：（不支持插入多行，不支持子查询）</span><br><span class="line">		insert into 表名</span><br><span class="line">		set 列名&#x3D;值, 列名&#x3D;值, ......;</span><br><span class="line"></span><br><span class="line">特点：</span><br><span class="line">    1、字段类型和值类型一致或兼容，而且一一对应</span><br><span class="line">    2、可以为空的字段，可以不用插入值，或用null填充</span><br><span class="line">    3、不可以为空的字段，必须插入值</span><br><span class="line">    4、字段个数和值的个数必须一致</span><br><span class="line">    5、字段可以省略，但默认所有字段，并且顺序和表中的存储顺序一致</span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">#方式一：多行</span><br><span class="line">insert into beauty(id, name, sex, borndate)</span><br><span class="line">values(13, &#39;唐艺昕&#39;, &#39;女&#39;, &#39;1990-4-3&#39;), (14, &#39;刘亦菲&#39;, &#39;女&#39;, &#39;1987-4-3&#39;);</span><br><span class="line"></span><br><span class="line">#方式一：子查询（会把结果插入对应的字段中）</span><br><span class="line">insert into beauty(id, name, phone)</span><br><span class="line">select 26, &#39;宋茜&#39;, &#39;88888888888&#39;</span><br><span class="line"></span><br><span class="line">#方式二：</span><br><span class="line">insert into beauty</span><br><span class="line">set id&#x3D;13, name&#x3D;&#39;唐嫣&#39;, sex&#x3D;&#39;女&#39;, borndate&#x3D;&#39;1998-9-1&#39;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">修改单表语法：</span><br><span class="line">	update 表名 </span><br><span class="line">	set 字段&#x3D;新值,字段&#x3D;新值</span><br><span class="line">	【where 条件】</span><br><span class="line">	</span><br><span class="line">修改多表语法：</span><br><span class="line">	update 表1 别名1,表2 别名2</span><br><span class="line">	set 字段&#x3D;新值，字段&#x3D;新值</span><br><span class="line">	where 连接条件</span><br><span class="line">	and 筛选条件</span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">#修改beauty表中姓唐的女神的电话为88888888888, </span><br><span class="line">update beauty</span><br><span class="line">set phone&#x3D;&#39;88888888888&#39;</span><br><span class="line">where name like &#39;唐%&#39;;</span><br><span class="line"></span><br><span class="line">#修改张无忌女朋友的手机号为123</span><br><span class="line">update boys bo</span><br><span class="line">inner join beauty b</span><br><span class="line">on bo.id &#x3D; b.boyfriend_id</span><br><span class="line">where bo.boyName&#x3D;&#39;张无忌&#39;;</span><br></pre></td></tr></table></figure>
<h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">单表的删除：</span><br><span class="line">	delete from 表名 【where 筛选条件】</span><br><span class="line"></span><br><span class="line">多表的删除：</span><br><span class="line">	delete 别名1，别名2</span><br><span class="line">	from 表1 别名1，表2 别名2</span><br><span class="line">	where 连接条件</span><br><span class="line">	and 筛选条件;</span><br><span class="line"></span><br><span class="line">	truncate语句：（又称清空，一次删除整个表，不能加where条件）</span><br><span class="line">		truncate table 表名</span><br><span class="line">		</span><br><span class="line">区别：</span><br><span class="line">	1.truncate不能加where条件，而delete可以加where条件</span><br><span class="line">	2.truncate的效率高一丢丢</span><br><span class="line">	3.truncate 删除带自增长的列的表后，如果再插入数据，数据从1开始delete 删除带自增长列的表后，如果再插入数据，数据从上一次的断点处开始</span><br><span class="line">	4.truncate删除不能回滚，delete删除可以回滚</span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">#删除手机号以9结尾的女神信息</span><br><span class="line">delete from beauty where phone like &#39;%9&#39;;</span><br><span class="line"></span><br><span class="line">#删除张无忌女朋友的信息</span><br><span class="line">delete b</span><br><span class="line">from beauty b</span><br><span class="line">inner join boys bo</span><br><span class="line">on b.boyfriend_id &#x3D; bo.id</span><br><span class="line">where bo.boyName &#x3D; &#39;张无忌&#39;;</span><br><span class="line"></span><br><span class="line">#删除黄晓明的信息和他女朋友的信息</span><br><span class="line">delete b, bo</span><br><span class="line">from beauty b</span><br><span class="line">inner join boys bo</span><br><span class="line">on b.boyfriend_id &#x3D; bo.id</span><br><span class="line">where bo.boyName &#x3D; &#39;黄晓明&#39;;</span><br></pre></td></tr></table></figure>
<h3 id="2、DDL语言"><a href="#2、DDL语言" class="headerlink" title="2、DDL语言"></a><strong>2、DDL语言</strong></h3><h4 id="库的管理"><a href="#库的管理" class="headerlink" title="库的管理"></a>库的管理</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#库的管理</span><br><span class="line">    一、创建库</span><br><span class="line">    create database (if not exists) 库名;</span><br><span class="line">    二、删除库</span><br><span class="line">    drop database (if exists) 库名;</span><br><span class="line">    三、库的修改</span><br><span class="line">    alter database 旧库名 to 新库名;</span><br></pre></td></tr></table></figure>
<h4 id="表的管理"><a href="#表的管理" class="headerlink" title="表的管理"></a>表的管理</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#表的管理</span><br><span class="line">	一、表的创建</span><br><span class="line">        create table 表名(</span><br><span class="line">            列名 列的类型 【(长度)约束】,</span><br><span class="line">            列名 列的类型 【(长度)约束】,</span><br><span class="line">            列名 列的类型 【(长度)约束】,</span><br><span class="line">            ...</span><br><span class="line">        );</span><br><span class="line">        例如：</span><br><span class="line">        CREATE TABLE IF NOT EXISTS stuinfo(</span><br><span class="line">            stuId INT,</span><br><span class="line">            stuName VARCHAR(20),</span><br><span class="line">            gender CHAR,</span><br><span class="line">            bornDate DATETIME</span><br><span class="line">        );</span><br><span class="line">	二、表的修改</span><br><span class="line">		1、修改列名</span><br><span class="line">			alter table 表名 change 【column】 旧列名 新列名 类型;</span><br><span class="line">			例如：</span><br><span class="line">			alter table book change column publishdate pubdate datetime;</span><br><span class="line">		2、修改列的类型或约束</span><br><span class="line">			alter table 表名 modify column 列名 类型;</span><br><span class="line">			例如：</span><br><span class="line">			alter table book modify column pubdate timestamp;</span><br><span class="line">		3、添加新列</span><br><span class="line">			alter table 表名 add column 列名 类型;</span><br><span class="line">			例如：</span><br><span class="line">			alter table author add column annual double;</span><br><span class="line">		4、删除列</span><br><span class="line">			alter table 表名 drop column 列名 类型;</span><br><span class="line">			例如：</span><br><span class="line">			alter table author drop column annual double;</span><br><span class="line">		5、修改表名</span><br><span class="line">			alter table 旧表名 rename to 新表名;</span><br><span class="line">			例如：</span><br><span class="line">			alter table author rename to zuozhe;</span><br><span class="line">	三、表的删除</span><br><span class="line">		drop table 【if exists】 表名;</span><br><span class="line">	四、表的复制</span><br><span class="line">		1、只复制表的结构，不复制数据</span><br><span class="line">			create table 新表名 like 被复制表名;</span><br><span class="line">			例如：</span><br><span class="line">			create table copy_author like author;</span><br><span class="line">		2、复制表的结构 + 全部数据</span><br><span class="line">			create table 新表名 select * from 被复制表名;</span><br><span class="line">			例如：</span><br><span class="line">			create table copy_author select * from author;</span><br><span class="line">		3、复制表的结构 + 部分数据</span><br><span class="line">			create table 新表名</span><br><span class="line">			select 列名, 列名, ...</span><br><span class="line">			from 被复制表名</span><br><span class="line">			【where 筛选条件】 ;</span><br><span class="line">		4、只复制部分结构</span><br><span class="line">			create table 新表名</span><br><span class="line">			select 列名, 列名, ...</span><br><span class="line">			from 被复制表名</span><br><span class="line">			where 0;</span><br><span class="line">		</span><br></pre></td></tr></table></figure>
<h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><h5 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h5><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">1、整数</span><br><span class="line">	特点：</span><br><span class="line">		<span class="selector-tag">a</span>.默认是有符号，无符号需添加unsigned关键字</span><br><span class="line">		<span class="selector-tag">b</span>.若插入的数值超出范围，会报out of range异常， 并且插入临界值</span><br><span class="line">		c.如果不设置长度，会有默认长度，长度代表了显示的最大宽度，如果不够会用0在左边填充，但必须搭配zerofill使用</span><br><span class="line">2、小数</span><br><span class="line">	分类：</span><br><span class="line">		<span class="selector-tag">a</span>.浮点型</span><br><span class="line">			<span class="attribute">float</span>(M, D)</span><br><span class="line">			double(M, D)</span><br><span class="line">		<span class="selector-tag">b</span>.定点型</span><br><span class="line">			dec(M, D)</span><br><span class="line">			decimal(M, D)</span><br><span class="line">	特点：</span><br><span class="line">		M：整数部位长度+小数部位长度</span><br><span class="line">		D：小数部位长度</span><br><span class="line">	注意：M和D都可以省略，如果是decimal，则M默认是10， D默认是0</span><br><span class="line">		 			   如果是<span class="attribute">float</span>和double，则会根据插入的数值精度来决定精度</span><br><span class="line">	总结：定点型的精度较高，如果要求插入数值的精度较高如货币运算等可以考虑使用</span><br></pre></td></tr></table></figure>
<h5 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、较短的文本（M为字符数）</span><br><span class="line">	char(M)       固定长度的字符    空间耗费大，但效率高</span><br><span class="line">	varchar(M)	  可变长度的字符    空间耗费小，但效率低</span><br><span class="line">2、较长的文本</span><br><span class="line">	text</span><br><span class="line">	blob</span><br><span class="line"></span><br><span class="line">#--------------------------------------------------------------------</span><br><span class="line">enum类型：</span><br><span class="line"># 又称枚举类型，要求插入的值必须属于列表中指定的值之一</span><br><span class="line"></span><br><span class="line">create table tab_char(</span><br><span class="line">	c enum(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">insert into tab_char values(&#39;a&#39;);</span><br><span class="line">insert into tab_char values(&#39;b&#39;);</span><br><span class="line">insert into tab_char values(&#39;c&#39;);</span><br><span class="line">insert into tab_char values(&#39;A&#39;);</span><br><span class="line">insert into tab_char values(&#39;m&#39;);  #报错，因为不包含在枚举列表中</span><br><span class="line"></span><br><span class="line">#---------------------------------------------------------------------</span><br><span class="line">set类型</span><br><span class="line"># 和enum类型类似，区别在于set类型一次可以选取多个成员，而enum只能选取一个成员</span><br><span class="line"></span><br><span class="line">create table tab_set(</span><br><span class="line">	s set(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">insert into tab_set values(&#39;a&#39;);</span><br><span class="line">insert into tab_set values(&#39;a, b&#39;);</span><br><span class="line">insert into tab_set values(&#39;A, b, c&#39;);</span><br></pre></td></tr></table></figure>
<h4 id="常见约束"><a href="#常见约束" class="headerlink" title="常见约束"></a>常见约束</h4><h5 id="创建表时添加约束"><a href="#创建表时添加约束" class="headerlink" title="创建表时添加约束"></a>创建表时添加约束</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#含义：一种限制，用于限制表中的数据，为了保证表中的数据的准确性和可靠性</span><br><span class="line">&#x2F;*</span><br><span class="line">常见六大约束：</span><br><span class="line">    NOT NULL			保证字段不为空</span><br><span class="line">    DEFAULT				保证字段有默认值</span><br><span class="line">    UNIQUE				唯一，保证字段值具有唯一性，可以为空</span><br><span class="line">    CHECK				检查约束（mysql不支持）</span><br><span class="line">    PRIMARY KEY		     主键，保证字段值具有唯一性，不能为空</span><br><span class="line">    FOREIGN KEY			 外键，用于限制两个表的关系，保证该字段的值必须来自于主表的关联列的值，在从表中添加外键约束，用于引用主表中某列的值</span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">#创建表时添加约束</span><br><span class="line">一、添加列级约束</span><br><span class="line">&#x2F;*	语法：</span><br><span class="line">		直接在字段名和类型后面追加约束类型即可</span><br><span class="line">		只支持：默认、非空、主键、唯一</span><br><span class="line">*&#x2F;</span><br><span class="line">		</span><br><span class="line">create table stuinfo(</span><br><span class="line">	id int primary key,		#主键</span><br><span class="line">    stuName varchar(20) not null,		#非空</span><br><span class="line">    gender char(1) check(gender&#x3D;&#39;男&#39; or gender&#x3D;&#39;女&#39;),		#检查</span><br><span class="line">    seat int unique,		#唯一</span><br><span class="line">    age int default,		#默认约束</span><br><span class="line">    majorId int references(id)		#外键</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">二、添加表级约束</span><br><span class="line">&#x2F;*</span><br><span class="line">语法：在各个字段的最下面</span><br><span class="line">	【constraint 约束名】 约束类型(字段名);</span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">create table stuinfo(</span><br><span class="line">	id int,</span><br><span class="line">    stuname varchar(20),</span><br><span class="line">    gender char(1),</span><br><span class="line">    seat int,</span><br><span class="line">    age int,</span><br><span class="line">    majorid int,</span><br><span class="line">    </span><br><span class="line">    constraint pk primary key(id),		#主键</span><br><span class="line">    constraint uq unique(seat),			#唯一键</span><br><span class="line">    constraint ck check(gender&#x3D;&#39;男&#39; or gender&#x3D;&#39;女&#39;),		#检查</span><br><span class="line">    constraint fk_stuinfo_major foreign key(majorid) references major(id) #外键</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">三、通用写法</span><br><span class="line">create table if not exists stuinfo(</span><br><span class="line">	id int primary key,</span><br><span class="line">    stuName varchar(20) not null,</span><br><span class="line">    sex char(1),</span><br><span class="line">    seat int unique 18,</span><br><span class="line">    age int default,</span><br><span class="line">    majorId int,</span><br><span class="line">    constraint fk_stuinfo_major foreign key(majorid) references major(id)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line">主键和唯一的对比：</span><br><span class="line">		唯一性		是否允许为空		一个表中可以有多少个		是否允许组合</span><br><span class="line">主键		√			×				一个					允许（不推荐）</span><br><span class="line">唯一		√			√				多个					允许（不推荐）</span><br><span class="line"></span><br><span class="line">外键：</span><br><span class="line">	1、要求在从表设置外键关系</span><br><span class="line">	2、从表的外键列的类型和主表的关联列的类型要求一致或兼容，名称无要求</span><br><span class="line">	3、主表的关联列必须是一个key（一般是主键或唯一）</span><br><span class="line">	4、插入数据时，先插入主表，再插入从表；删除数据时，先删除从表，再删除主表</span><br><span class="line"></span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure>
<h5 id="修改表时添加约束"><a href="#修改表时添加约束" class="headerlink" title="修改表时添加约束"></a>修改表时添加约束</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">1、添加列级约束</span><br><span class="line">	alter table 表名 modify column 字段名 字段类型 新约束;</span><br><span class="line">2、添加表级约束</span><br><span class="line">	alter table 表名 add 【constraint 约束名】 约束类型(字段名) 【外键的引用】;</span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">alter table stuinfo modify column stuname varchar(20) not null;</span><br><span class="line"></span><br><span class="line">alter table stuinfo modify column age int default 18;</span><br><span class="line"></span><br><span class="line">alter table stuinfo modify column id int primary key;</span><br><span class="line">alter table stuinfo add primary key(id);</span><br><span class="line"></span><br><span class="line">alter table stuinfo modify column seat int unique;</span><br><span class="line">alter table stuinfo add unique(seat);</span><br><span class="line"></span><br><span class="line">alter table stuinfo add foreign key(majorid) references major(id);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="修改表时删除约束"><a href="#修改表时删除约束" class="headerlink" title="修改表时删除约束"></a>修改表时删除约束</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter table stuinfo modify column stuname varchar(20) null;</span><br><span class="line"></span><br><span class="line">alter table stuinfo modify column age int;</span><br><span class="line"></span><br><span class="line">alter table stuinfo drop primary key;</span><br><span class="line"></span><br><span class="line">alter table stuinfo drop index seat;</span><br><span class="line"></span><br><span class="line">alter table stuinfo drop foreign key fk_stuinfo_major;</span><br></pre></td></tr></table></figure>
<h4 id="标识列"><a href="#标识列" class="headerlink" title="标识列"></a>标识列</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">又称自增长列，可以不用手动插入值，系统提供默认的序列值</span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line">1、标识列不一定要和主键搭配，但要求是一个key</span><br><span class="line">2、一个表最多可以有一个标识列</span><br><span class="line">3、标识列的类型只能是数值型</span><br><span class="line">4、标识列可以通过  set auto_increment_increment&#x3D;3; 设置步长，可以手动插入值，设置起始值</span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">一、创建表时设置标识列</span><br><span class="line">create table tab_identity(</span><br><span class="line">	id int primary key auto_increment,</span><br><span class="line">    name varchar(20)</span><br><span class="line">);</span><br><span class="line">#会自动创建1-20的id</span><br><span class="line">insert into tab_identity(id, name) values(null, &#39;john&#39;);</span><br><span class="line"></span><br><span class="line">二、修改表时设置标识列</span><br><span class="line">alter table tab_identity modify column id int primary key auto_increment;</span><br><span class="line"></span><br><span class="line">三、修改表时删除标识列</span><br><span class="line">alter table tab_identity modify column id int;</span><br></pre></td></tr></table></figure>
<h3 id="3、TCL语言"><a href="#3、TCL语言" class="headerlink" title="3、TCL语言"></a><strong>3、TCL语言</strong></h3><h4 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">transaction control language：事务控制语言</span><br><span class="line">事务：</span><br><span class="line">	一个或一组sql语句组成一个执行单元，这个执行单元要么全部执行，要么全部不执行</span><br><span class="line">*&#x2F;</span><br><span class="line">&#x2F;*</span><br><span class="line">事务的特性：</span><br><span class="line">	原子性：一个事务不可再分割，要么都执行要么都不执行</span><br><span class="line">	一致性：一个事务执行会使数据从一个一致状态切换到另外一个一直状态</span><br><span class="line">	隔离性：一个事务的执行不受其他事务的干扰</span><br><span class="line">	持久性：一个事务一旦提交，则会永久的改变数据库的数据</span><br><span class="line"></span><br><span class="line">事务的创建：</span><br><span class="line">	隐式事务：事务没有明显的开启或结束的标记，比如insert、update、delete语句</span><br><span class="line">	显示事务：事务具有明显的开启或结束的标记，前提：必须先设置自动提交功能为禁用</span><br><span class="line">			set autocommit&#x3D;0;</span><br><span class="line">			</span><br><span class="line">			步骤1：开启事务</span><br><span class="line">				set autommit&#x3D;0;</span><br><span class="line">				start transaction;（可选）</span><br><span class="line">			步骤2：编写事务中的sql语句（select、insert、update、delete）</span><br><span class="line">				语句1;</span><br><span class="line">				语句2;</span><br><span class="line">				...</span><br><span class="line">			步骤3：结束事务</span><br><span class="line">				commit; （提交事务）</span><br><span class="line">				rollback; （回滚事务）</span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">set autocommit&#x3D;0;</span><br><span class="line">start transaction;</span><br><span class="line">update account set balance &#x3D; 500 where username&#x3D;&#39;张无忌&#39;;</span><br><span class="line">update account set balance &#x3D; 1500 where username&#x3D;&#39;赵敏&#39;;</span><br><span class="line">commit;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line">事务并发问题如何发生？</span><br><span class="line">	当多个事务同时操作同一个数据库的相同数据时</span><br><span class="line">	</span><br><span class="line">事务的并发问题有哪些？</span><br><span class="line">	脏读：一个事务读取到了另外一个事务未提交的数据</span><br><span class="line">	不可重复读：同一个事务中，多次读取到的数据不一致</span><br><span class="line">	幻读：一个事务读取数据时，另一个事务进行更新，导致第一个事务读取到了没有更新的数据</span><br><span class="line"></span><br><span class="line">如何避免事务的并发问题？</span><br><span class="line">	通过设置事务的隔离级别</span><br><span class="line">	1、read uncommitted</span><br><span class="line">	2、read committed 可以避免脏读</span><br><span class="line">	3、repeatable read 可以避免脏读、不可重复读和一部分幻读</span><br><span class="line">	4、serializable 可以避免脏读、不可重复读和幻读</span><br><span class="line"></span><br><span class="line">设置隔离级别：</span><br><span class="line">	set session|global  transaction isolation level 隔离级别名;</span><br><span class="line"></span><br><span class="line">查看隔离级别：</span><br><span class="line">	select @@tx_isolation;</span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="4、视图"><a href="#4、视图" class="headerlink" title="4、视图"></a><strong>4、视图</strong></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#视图</span><br><span class="line">&#x2F;*</span><br><span class="line">含义：</span><br><span class="line">	虚拟表，和普通表一样使用</span><br><span class="line">好处：</span><br><span class="line">	1、sql语句提高重用性，效率高</span><br><span class="line">	2、和表实现了分离，提高了安全性</span><br><span class="line">视图和表的区别：</span><br><span class="line">			  使用方式	   占用物理空间				语法</span><br><span class="line"></span><br><span class="line">		视图	 完全相同	不占用，仅仅保存的是sql逻辑    create view</span><br><span class="line">		表	  完全相同	 占用						  create table</span><br><span class="line">*&#x2F;</span><br><span class="line">一、视图的创建</span><br><span class="line">#查询姓名中包含a字符的员工名、部门名和工种信息</span><br><span class="line">1、创建</span><br><span class="line">create view myview</span><br><span class="line">as</span><br><span class="line">select last_name, department_name, job_title</span><br><span class="line">from employees e</span><br><span class="line">join departments d on e.department_id &#x3D; d.department_id</span><br><span class="line">join jobs j on e.job_id &#x3D; j.job_id;</span><br><span class="line">2、使用</span><br><span class="line">select * from myview where last_name like &#39;%a%&#39;;</span><br><span class="line"></span><br><span class="line">#查询平均工资最低的部门名和工资</span><br><span class="line">create view myv2</span><br><span class="line">as</span><br><span class="line">select avg(salary) ag</span><br><span class="line">from employees</span><br><span class="line">group by department_id;</span><br><span class="line"></span><br><span class="line">create view myv3</span><br><span class="line">as</span><br><span class="line">select * from myv2</span><br><span class="line">order by ag</span><br><span class="line">limit 1;</span><br><span class="line"></span><br><span class="line">select d.*, m.ag</span><br><span class="line">from myv3 m</span><br><span class="line">join departments d</span><br><span class="line">on m.department_id &#x3D; d.department_id;</span><br><span class="line"></span><br><span class="line">二、视图的修改</span><br><span class="line">&#x2F;*</span><br><span class="line">	方式一：</span><br><span class="line">        create or replace view 视图名</span><br><span class="line">        as</span><br><span class="line">        查询语句</span><br><span class="line">*&#x2F;</span><br><span class="line">create or replace view myv3</span><br><span class="line">as</span><br><span class="line">select avg(salary), job_id</span><br><span class="line">from employees</span><br><span class="line">group by job_id;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line">	方式二：</span><br><span class="line">        alter view 视图名</span><br><span class="line">        as</span><br><span class="line">        查询语句</span><br><span class="line">*&#x2F;</span><br><span class="line">alter view myv3</span><br><span class="line">as</span><br><span class="line">select * from employees;</span><br><span class="line"></span><br><span class="line">三、视图的删除</span><br><span class="line">&#x2F;*</span><br><span class="line">	语法：</span><br><span class="line">		drop view 视图名, 视图名, ...</span><br><span class="line">*&#x2F;</span><br><span class="line">drop view myv1, myv2, myv3;</span><br><span class="line"></span><br><span class="line">四、视图的查看</span><br><span class="line">&#x2F;*</span><br><span class="line">	语法：</span><br><span class="line">		show create view 视图名;</span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">五、视图的更新（更改数据）</span><br><span class="line">	1、插入</span><br><span class="line">		insert into myv1 values(&#39;张飞&#39;, &#39;zf@qq.com&#39;);</span><br><span class="line">	2、修改</span><br><span class="line">		update myv1 set last_name &#x3D; &#39;张无忌&#39; where last_name &#x3D; &#39;张飞&#39;;</span><br><span class="line">	3、删除</span><br><span class="line">		delete from myv1 where last_name &#x3D; &#39;张无忌&#39;;</span><br></pre></td></tr></table></figure>
<h3 id="5、变量"><a href="#5、变量" class="headerlink" title="5、变量"></a><strong>5、变量</strong></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">系统变量：</span><br><span class="line">	全局变量：服务器每次启动将为所有的全局变量赋初值，针对于所有的会话有效，但不能			    跨重启</span><br><span class="line">	会话变量：仅仅针对当前会话有效</span><br><span class="line">自定义变量：</span><br><span class="line">	用户变量：针对于当前会话有效，应用在任何地方，即begin end里面或begin end外面</span><br><span class="line">	局部变量：仅仅在它的begin end中有效，应用在begin end中的第一句话</span><br><span class="line">*&#x2F;</span><br><span class="line">一、系统变量</span><br><span class="line">说明：由系统提供，属于服务器层面</span><br><span class="line">1、查询所有的系统变量</span><br><span class="line">show global|【session】 variables;</span><br><span class="line">2、查看满足条件的部分系统变量</span><br><span class="line">show global|【session】 variables like &#39;%char%&#39;;</span><br><span class="line">3、查看指定的某个系统变量的值</span><br><span class="line">select @@global|【session】.系统变量名;</span><br><span class="line">4、为某个系统变量赋值</span><br><span class="line">set global|【session】 系统变量名&#x3D;值;</span><br><span class="line">set @@global|【session】.系统变量名&#x3D;值;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">二、自定义变量</span><br><span class="line">1、说明：用户自定义变量</span><br><span class="line">    使用步骤：</span><br><span class="line">    声明-&gt;赋值-&gt;使用</span><br><span class="line">    1、声明并初始化</span><br><span class="line">    set @用户变量名&#x3D;值; </span><br><span class="line">    或</span><br><span class="line">    set@用户变量名:&#x3D;值; </span><br><span class="line">    或</span><br><span class="line">    select @用户变量名:&#x3D;值;</span><br><span class="line"></span><br><span class="line">    2、赋值（更新用户变量的值）</span><br><span class="line">    方式一：</span><br><span class="line">    set @用户变量名&#x3D;值; </span><br><span class="line">    或</span><br><span class="line">    set@用户变量名:&#x3D;值; </span><br><span class="line">    或</span><br><span class="line">    select @用户变量名:&#x3D;值;</span><br><span class="line">    方式二：</span><br><span class="line">    select 字段 into 变量名</span><br><span class="line">    from 表;</span><br><span class="line"></span><br><span class="line">    3、使用</span><br><span class="line">    select @用户变量名;</span><br><span class="line"></span><br><span class="line">    例如：</span><br><span class="line">        set @name&#x3D;&#39;john&#39;;</span><br><span class="line">        set @name&#x3D;100;</span><br><span class="line">        set @count&#x3D;1;</span><br><span class="line"></span><br><span class="line">        select count(*) into @count</span><br><span class="line">        from employees;</span><br><span class="line"></span><br><span class="line">        select @count;</span><br><span class="line">    </span><br><span class="line">2、局部变量：</span><br><span class="line">	1、声明</span><br><span class="line">		declare 变量名 类型;</span><br><span class="line">		declare 变量名 类型 default 值;</span><br><span class="line">	2、赋值</span><br><span class="line">		方式一：通过 set 或 select</span><br><span class="line">			set 局部变量名&#x3D;值;</span><br><span class="line">			或</span><br><span class="line">			set 局部变量名:&#x3D;值;</span><br><span class="line">			或</span><br><span class="line">			select @局部变量名:&#x3D;值;</span><br><span class="line">		方式二：通过 select into</span><br><span class="line">			select 字段 into 局部变量名</span><br><span class="line">			from 表;</span><br><span class="line">	3、使用</span><br><span class="line">		select 局部变量名;</span><br><span class="line">		</span><br><span class="line">	例如：</span><br><span class="line">		declare m int default 1;</span><br><span class="line">		declare n int default 2;</span><br><span class="line">		declare sum int;</span><br><span class="line">		set sum&#x3D;m+n;</span><br><span class="line">		select sum;</span><br></pre></td></tr></table></figure>
<h3 id="6、存储过程和函数"><a href="#6、存储过程和函数" class="headerlink" title="6、存储过程和函数"></a><strong>6、存储过程和函数</strong></h3><h4 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">含义：一组预先编译好的SQL语句的集合，理解成批处理语句</span><br><span class="line">	1、提高代码的重用性</span><br><span class="line">	2、简化过程</span><br><span class="line">	3、减少了编译次数并且减少了和数据库服务器的连接次数，提高了效率</span><br><span class="line"></span><br><span class="line">一、创建语法</span><br><span class="line">create procedure 存储过程名(参数列表)</span><br><span class="line">begin</span><br><span class="line">	存储过程体（一组合法的SQL语句）</span><br><span class="line">end</span><br><span class="line">注意：</span><br><span class="line">1、参数列表包含三部分</span><br><span class="line">    参数模式 参数名 参数类型</span><br><span class="line"></span><br><span class="line">    例如： in stuname varchar(20)</span><br><span class="line"></span><br><span class="line">    参数模式：</span><br><span class="line">        in：该参数可以作为输入，需要调入方传入值</span><br><span class="line">        out：该参数可以作为输出，该参数可以作为返回值</span><br><span class="line">        inout：该参数既可以作为输入又可以作为输出，也就是该参数既需要传入值，又可以返回值</span><br><span class="line"></span><br><span class="line">2、如果存储过程体仅仅只有一句话， begin end 可以省略</span><br><span class="line">	存储过程体中的每条SQL语句的结尾要求必须加分号</span><br><span class="line">	存储过程的结尾可以使用 delimiter 重新设置</span><br><span class="line">	语法：</span><br><span class="line">		delimiter 结束标记</span><br><span class="line">		例如：</span><br><span class="line">		delimiter $</span><br><span class="line"></span><br><span class="line">二、调用语法</span><br><span class="line">call 存储过程名（实参列表）;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">三、参数前面的符号的意思</span><br><span class="line">in:该参数只能作为输入 （该参数不能做返回值）</span><br><span class="line">out：该参数只能作为输出（该参数只能做返回值）</span><br><span class="line">inout：既能做输入又能做输出</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>股票基础知识</title>
    <url>/2021/07/10/%E8%82%A1%E7%A5%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1、股票分类"><a href="#1、股票分类" class="headerlink" title="1、股票分类"></a>1、股票分类</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">上证A股  60开头</span><br><span class="line">深圳A股  0开头</span><br><span class="line">创业板   3开头（去证券公司开通）</span><br><span class="line">科创板   688开头（目前政策：最低50W资金）</span><br></pre></td></tr></table></figure>
<h3 id="2、交易时间"><a href="#2、交易时间" class="headerlink" title="2、交易时间"></a>2、交易时间</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">周一到周五：</span><br><span class="line">上午 9：30-11：30</span><br><span class="line">下午 13—：00-15：00</span><br><span class="line">周六日不交易</span><br><span class="line">国家法定节日不交易</span><br><span class="line"></span><br><span class="line">集合竞价：</span><br><span class="line">9：15-9：20 随便挂单随便撤单</span><br><span class="line">9：20-9：25 可以挂单，不可撤单时间</span><br></pre></td></tr></table></figure>
<h3 id="3、股票的涨跌幅"><a href="#3、股票的涨跌幅" class="headerlink" title="3、股票的涨跌幅"></a>3、股票的涨跌幅</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">沪深A股：0和60开头的股票每天的涨跌幅是10%（最高涨10%，最低跌10%，即涨停和跌停）</span><br><span class="line">创业板：3开头的股票每天的涨跌幅是20%</span><br><span class="line">新股：第一天涨跌幅44%（68开头的科创板除外）</span><br><span class="line">科创版：68开头的股票，前5个交易日无限制，后面涨跌幅为20%</span><br><span class="line">ST股：亏损股的涨跌幅是5%</span><br></pre></td></tr></table></figure>
<h3 id="4、股票k线图"><a href="#4、股票k线图" class="headerlink" title="4、股票k线图"></a>4、股票k线图</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">涨：红色</span><br><span class="line">最高价</span><br><span class="line">收盘价</span><br><span class="line">开盘价</span><br><span class="line">最低价</span><br><span class="line"></span><br><span class="line">跌：绿色</span><br><span class="line">最高价</span><br><span class="line">开盘价</span><br><span class="line">收盘价</span><br><span class="line">最低价</span><br></pre></td></tr></table></figure>
<p><img src= "/img/loading.gif" data-lazy-src="https://img2.baidu.com/it/u=408237037,1107597697&fm=26&fmt=auto&gp=0.jpg" alt="股票k线图"></p>
<h3 id="5、交易规则"><a href="#5、交易规则" class="headerlink" title="5、交易规则"></a>5、交易规则</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">股票最低买1手</span><br><span class="line">1手 &#x3D; 100 股</span><br><span class="line">即：按100股的整数倍来买</span><br><span class="line">例如：每股13元，则一手总共需要1300元</span><br><span class="line"></span><br><span class="line">当前股票交易费用分为三部分：佣金、印花税、过户费（仅上海股票收取）</span><br><span class="line">1、印花税：1‰（卖的时候才收取，为国家税收，全国统一）</span><br><span class="line">2、过户费：深圳交易所无此项费用，上海交易所收费标准：按成交金额的0.02‰人民币</span><br><span class="line">3、交易佣金：最高收费为3&#x2F;10000，最低收费为5&#x2F;10000，各家券商收费不一。</span><br></pre></td></tr></table></figure>
<h3 id="6、看盘界面"><a href="#6、看盘界面" class="headerlink" title="6、看盘界面"></a>6、看盘界面</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">均线：n天的收盘价相加，除以n天，用线连起来</span><br><span class="line">例如：MA5：5天的均价线，5可以修改为其它想看的数值</span><br><span class="line">	</span><br><span class="line">成交量：n天所有的成交量相加，再除以n天，用线连起来</span><br></pre></td></tr></table></figure>
<h3 id="7、股票趋势"><a href="#7、股票趋势" class="headerlink" title="7、股票趋势"></a>7、股票趋势</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">顺势而为，尽量做上涨趋势的股票，行情好时入手</span><br><span class="line"></span><br><span class="line">压力位：当股价上涨快要到达上一次上涨趋势的高位时，为压力位，可以考虑卖出股票</span><br><span class="line">支撑位：当股价下跌快要到达上一次下跌趋势的低位时，为支撑位，可以考虑买入股票</span><br></pre></td></tr></table></figure>
<h3 id="8、突破和跌破"><a href="#8、突破和跌破" class="headerlink" title="8、突破和跌破"></a>8、突破和跌破</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">突破：当股价上涨过程中，价格冲过上一次上涨趋势的高位时，称之为突破，上涨力量很大，可以考虑买入股票</span><br><span class="line">跌破：当股票下跌过程中，股价下跌冲过上一次的下跌趋势低位时，称之为跌破，下跌力量很大，可以考虑卖出股票</span><br></pre></td></tr></table></figure>
<h3 id="9、买卖机制"><a href="#9、买卖机制" class="headerlink" title="9、买卖机制"></a>9、买卖机制</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">T+1机制：今天买的股票，必须过完本天以后，到第二天的交易日开始才可以卖出</span><br></pre></td></tr></table></figure>
<h3 id="10、如何选股"><a href="#10、如何选股" class="headerlink" title="10、如何选股"></a>10、如何选股</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、基本面选股：根据k线图走势选股</span><br><span class="line">2、热点题材选股：市场行情热点板块选股</span><br><span class="line">3、事件突发选股：根据突发情况选股</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>理财</category>
      </categories>
      <tags>
        <tag>理财</tag>
        <tag>股票</tag>
      </tags>
  </entry>
</search>
